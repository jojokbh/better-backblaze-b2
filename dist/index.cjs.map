{"version":3,"file":"index.cjs","sources":["../src/constants.js","../src/core/progress-handler.js","../src/core/http-client.js","../src/core/retry-handler.js","../src/utils/headers.js","../src/managers/auth-manager.js","../src/utils/endpoints.js","../src/managers/bucket-manager.js","../src/utils/crypto.js","../src/managers/file-manager.js","../src/managers/key-manager.js","../src/b2-client.js","../src/core/error-handler.js","../src/utils/validation.js"],"sourcesContent":["// API constants and configuration values\n\n// B2 API Base URLs\nexport const B2_API_BASE_URL = 'https://api.backblazeb2.com';\nexport const B2_API_VERSION = 'v2';\n\n// API Endpoints\nexport const API_ENDPOINTS = {\n  // Authentication\n  AUTHORIZE_ACCOUNT: '/b2api/v4/b2_authorize_account',\n\n  // Bucket operations\n  CREATE_BUCKET: '/b2api/v2/b2_create_bucket',\n  DELETE_BUCKET: '/b2api/v2/b2_delete_bucket',\n  LIST_BUCKETS: '/b2api/v2/b2_list_buckets',\n  UPDATE_BUCKET: '/b2api/v2/b2_update_bucket',\n  GET_UPLOAD_URL: '/b2api/v2/b2_get_upload_url',\n\n  // File operations\n  UPLOAD_FILE: '/b2api/v2/b2_upload_file',\n  DOWNLOAD_FILE_BY_ID: '/b2api/v2/b2_download_file_by_id',\n  DOWNLOAD_FILE_BY_NAME: '/file',\n  LIST_FILE_NAMES: '/b2api/v2/b2_list_file_names',\n  LIST_FILE_VERSIONS: '/b2api/v2/b2_list_file_versions',\n  GET_FILE_INFO: '/b2api/v2/b2_get_file_info',\n  DELETE_FILE_VERSION: '/b2api/v2/b2_delete_file_version',\n  HIDE_FILE: '/b2api/v2/b2_hide_file',\n\n  // Large file operations\n  START_LARGE_FILE: '/b2api/v2/b2_start_large_file',\n  GET_UPLOAD_PART_URL: '/b2api/v2/b2_get_upload_part_url',\n  UPLOAD_PART: '/b2api/v2/b2_upload_part',\n  FINISH_LARGE_FILE: '/b2api/v2/b2_finish_large_file',\n  CANCEL_LARGE_FILE: '/b2api/v2/b2_cancel_large_file',\n  LIST_PARTS: '/b2api/v2/b2_list_parts',\n  LIST_UNFINISHED_LARGE_FILES: '/b2api/v2/b2_list_unfinished_large_files',\n\n  // Key management\n  CREATE_KEY: '/b2api/v2/b2_create_key',\n  DELETE_KEY: '/b2api/v2/b2_delete_key',\n  LIST_KEYS: '/b2api/v2/b2_list_keys',\n\n  // Download authorization\n  GET_DOWNLOAD_AUTHORIZATION: '/b2api/v2/b2_get_download_authorization',\n};\n\n// Bucket Types\nexport const BUCKET_TYPES = {\n  ALL_PRIVATE: 'allPrivate',\n  ALL_PUBLIC: 'allPublic',\n};\n\n// Key Capabilities\nexport const KEY_CAPABILITIES = {\n  LIST_KEYS: 'listKeys',\n  WRITE_KEYS: 'writeKeys',\n  DELETE_KEYS: 'deleteKeys',\n  LIST_BUCKETS: 'listBuckets',\n  WRITE_BUCKETS: 'writeBuckets',\n  DELETE_BUCKETS: 'deleteBuckets',\n  LIST_ALL_BUCKET_NAMES: 'listAllBucketNames',\n  LIST_FILES: 'listFiles',\n  READ_FILES: 'readFiles',\n  SHARE_FILES: 'shareFiles',\n  WRITE_FILES: 'writeFiles',\n  DELETE_FILES: 'deleteFiles',\n};\n\n// HTTP Status Codes\nexport const HTTP_STATUS = {\n  OK: 200,\n  CREATED: 201,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  REQUEST_TIMEOUT: 408,\n  TOO_MANY_REQUESTS: 429,\n  INTERNAL_SERVER_ERROR: 500,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n};\n\n// Default Configuration\nexport const DEFAULT_CONFIG = {\n  // Retry configuration\n  RETRY_ATTEMPTS: 3,\n  RETRY_DELAY: 1000, // 1 second\n  RETRY_DELAY_MULTIPLIER: 2,\n  MAX_RETRY_DELAY: 30000, // 30 seconds\n\n  // Request configuration\n  REQUEST_TIMEOUT: 30000, // 30 seconds\n  UPLOAD_TIMEOUT: 300000, // 5 minutes for uploads\n\n  // Large file configuration\n  RECOMMENDED_PART_SIZE: 100 * 1024 * 1024, // 100MB\n  MIN_PART_SIZE: 5 * 1024 * 1024, // 5MB\n  MAX_PART_SIZE: 5 * 1024 * 1024 * 1024, // 5GB\n  MAX_PARTS_COUNT: 10000,\n\n  // Progress reporting\n  PROGRESS_REPORT_INTERVAL: 1000, // 1 second\n};\n\n// Error Codes\nexport const B2_ERROR_CODES = {\n  BAD_AUTH_TOKEN: 'bad_auth_token',\n  EXPIRED_AUTH_TOKEN: 'expired_auth_token',\n  UNSUPPORTED_OPERATION: 'unsupported_operation',\n  INVALID_BUCKET_ID: 'invalid_bucket_id',\n  INVALID_BUCKET_NAME: 'invalid_bucket_name',\n  BUCKET_NOT_EMPTY: 'bucket_not_empty',\n  DUPLICATE_BUCKET_NAME: 'duplicate_bucket_name',\n  FILE_NOT_PRESENT: 'file_not_present',\n  NOT_ALLOWED: 'not_allowed',\n  REQUEST_TIMEOUT: 'request_timeout',\n  TOO_MANY_REQUESTS: 'too_many_requests',\n};\n\n// Retryable Error Codes\nexport const RETRYABLE_ERROR_CODES = new Set([\n  B2_ERROR_CODES.REQUEST_TIMEOUT,\n  B2_ERROR_CODES.TOO_MANY_REQUESTS,\n]);\n\n// Retryable HTTP Status Codes\nexport const RETRYABLE_STATUS_CODES = new Set([\n  HTTP_STATUS.REQUEST_TIMEOUT,\n  HTTP_STATUS.TOO_MANY_REQUESTS,\n  HTTP_STATUS.INTERNAL_SERVER_ERROR,\n  HTTP_STATUS.BAD_GATEWAY,\n  HTTP_STATUS.SERVICE_UNAVAILABLE,\n  HTTP_STATUS.GATEWAY_TIMEOUT,\n]);\n\n// Content Types\nexport const CONTENT_TYPES = {\n  JSON: 'application/json',\n  OCTET_STREAM: 'application/octet-stream',\n  TEXT_PLAIN: 'text/plain',\n};\n\n// Headers\nexport const HEADERS = {\n  AUTHORIZATION: 'Authorization',\n  CONTENT_TYPE: 'Content-Type',\n  CONTENT_LENGTH: 'Content-Length',\n  CONTENT_SHA1: 'X-Bz-Content-Sha1',\n  FILE_NAME: 'X-Bz-File-Name',\n  FILE_ID: 'X-Bz-File-Id',\n  PART_NUMBER: 'X-Bz-Part-Number',\n  TEST_MODE: 'X-Bz-Test-Mode',\n};\n","/**\n * Progress Handler for tracking upload and download progress\n * Provides progress callbacks for file operations using fetch streams\n */\n\nexport class ProgressHandler {\n  constructor(options = {}) {\n    this.options = options;\n  }\n\n  /**\n   * Create a progress event object\n   * @param {number} loaded - Number of bytes loaded\n   * @param {number} total - Total number of bytes\n   * @param {boolean} lengthComputable - Whether the total length is known\n   * @returns {Object} Progress event object\n   */\n  createProgressEvent(loaded, total, lengthComputable = true) {\n    return {\n      loaded,\n      total,\n      lengthComputable,\n      progress: lengthComputable && total > 0 ? loaded / total : 0,\n      percentage:\n        lengthComputable && total > 0 ? Math.round((loaded / total) * 100) : 0,\n    };\n  }\n\n  /**\n   * Create an upload progress tracker for fetch requests\n   * @param {Function} onProgress - Progress callback function\n   * @param {number} totalSize - Total size of the upload\n   * @returns {Function} Progress tracker function\n   */\n  createUploadProgressTracker(onProgress, totalSize) {\n    if (typeof onProgress !== 'function') {\n      return null;\n    }\n\n    let loaded = 0;\n\n    return (chunk) => {\n      if (chunk) {\n        loaded += chunk.length || chunk.byteLength || 0;\n      }\n\n      const progressEvent = this.createProgressEvent(\n        loaded,\n        totalSize,\n        totalSize > 0\n      );\n      onProgress(progressEvent);\n    };\n  }\n\n  /**\n   * Create a download progress tracker for fetch responses\n   * @param {Function} onProgress - Progress callback function\n   * @param {number} totalSize - Total size of the download (from Content-Length header)\n   * @returns {Function} Progress tracker function\n   */\n  createDownloadProgressTracker(onProgress, totalSize) {\n    if (typeof onProgress !== 'function') {\n      return null;\n    }\n\n    let loaded = 0;\n\n    return (chunk) => {\n      if (chunk) {\n        loaded += chunk.length || chunk.byteLength || 0;\n      }\n\n      const progressEvent = this.createProgressEvent(\n        loaded,\n        totalSize,\n        totalSize > 0\n      );\n      onProgress(progressEvent);\n    };\n  }\n\n  /**\n   * Wrap request body with progress tracking for uploads\n   * @param {any} body - Request body (Buffer, Uint8Array, string, etc.)\n   * @param {Function} progressTracker - Progress tracker function\n   * @returns {ReadableStream} Wrapped body with progress tracking\n   */\n  wrapUploadBody(body, progressTracker) {\n    if (!progressTracker || !body) {\n      return body;\n    }\n\n    // Convert body to Uint8Array if it's a string\n    let bodyData;\n    if (typeof body === 'string') {\n      bodyData = new TextEncoder().encode(body);\n    } else if (body instanceof ArrayBuffer) {\n      bodyData = new Uint8Array(body);\n    } else if (body instanceof Uint8Array || body instanceof Buffer) {\n      bodyData = body;\n    } else {\n      // For other types (FormData, Blob, etc.), return as-is\n      // Progress tracking for these types is handled differently\n      return body;\n    }\n\n    // Create a ReadableStream that tracks progress\n    return new ReadableStream({\n      start(controller) {\n        const chunkSize = 64 * 1024; // 64KB chunks\n        let offset = 0;\n\n        const pump = () => {\n          if (offset >= bodyData.length) {\n            controller.close();\n            return;\n          }\n\n          const chunk = bodyData.slice(offset, offset + chunkSize);\n          controller.enqueue(chunk);\n\n          // Track progress\n          progressTracker(chunk);\n\n          offset += chunk.length;\n\n          // Use setTimeout to avoid blocking the main thread\n          setTimeout(pump, 0);\n        };\n\n        pump();\n      },\n    });\n  }\n\n  /**\n   * Wrap response stream with progress tracking for downloads\n   * @param {Response} response - Fetch response object\n   * @param {Function} progressTracker - Progress tracker function\n   * @returns {ReadableStream} Wrapped response stream with progress tracking\n   */\n  wrapDownloadResponse(response, progressTracker) {\n    if (!progressTracker || !response.body) {\n      return response.body;\n    }\n\n    const reader = response.body.getReader();\n\n    return new ReadableStream({\n      start(controller) {\n        const pump = () => {\n          return reader\n            .read()\n            .then(({ done, value }) => {\n              if (done) {\n                controller.close();\n                return;\n              }\n\n              // Track progress\n              progressTracker(value);\n\n              controller.enqueue(value);\n              return pump();\n            })\n            .catch((error) => {\n              controller.error(error);\n            });\n        };\n\n        return pump();\n      },\n    });\n  }\n\n  /**\n   * Process response with progress tracking and return appropriate data type\n   * @param {Response} response - Fetch response object\n   * @param {string} responseType - Desired response type\n   * @param {Function} onDownloadProgress - Progress callback function\n   * @returns {Promise<any>} Processed response data\n   */\n  async processResponseWithProgress(\n    response,\n    responseType,\n    onDownloadProgress\n  ) {\n    if (!onDownloadProgress || !response.body) {\n      // No progress tracking needed, use standard processing\n      return this.processResponseWithoutProgress(response, responseType);\n    }\n\n    // Get content length for progress calculation\n    const contentLength = parseInt(\n      response.headers.get('content-length') || '0',\n      10\n    );\n    const progressTracker = this.createDownloadProgressTracker(\n      onDownloadProgress,\n      contentLength\n    );\n\n    // Wrap the response stream with progress tracking\n    const progressStream = this.wrapDownloadResponse(response, progressTracker);\n\n    // Create a new response with the wrapped stream\n    const progressResponse = new Response(progressStream, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    });\n\n    // Process the response based on the requested type\n    return this.processResponseWithoutProgress(progressResponse, responseType);\n  }\n\n  /**\n   * Process response without progress tracking (fallback method)\n   * @param {Response} response - Fetch response object\n   * @param {string} responseType - Desired response type\n   * @returns {Promise<any>} Processed response data\n   */\n  async processResponseWithoutProgress(response, responseType) {\n    switch (responseType) {\n      case 'stream':\n        return response.body;\n      case 'blob':\n        return await response.blob();\n      case 'arraybuffer':\n        return await response.arrayBuffer();\n      case 'text':\n        return await response.text();\n      case 'json':\n        return await response.json();\n      default:\n        // Auto-detect based on content type\n        const contentType = response.headers.get('content-type') || '';\n        if (contentType.includes('application/json')) {\n          try {\n            return await response.json();\n          } catch (error) {\n            return await response.text();\n          }\n        }\n        if (contentType.includes('text/')) {\n          return await response.text();\n        }\n        return await response.arrayBuffer();\n    }\n  }\n\n  /**\n   * Calculate upload body size for progress tracking\n   * @param {any} body - Request body\n   * @returns {number} Size in bytes\n   */\n  calculateBodySize(body) {\n    if (!body) {\n      return 0;\n    }\n\n    if (typeof body === 'string') {\n      return new TextEncoder().encode(body).length;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      return body.byteLength;\n    }\n\n    if (body instanceof Uint8Array || body instanceof Buffer) {\n      return body.length;\n    }\n\n    if (body instanceof Blob) {\n      return body.size;\n    }\n\n    if (body instanceof FormData) {\n      // FormData size is difficult to calculate precisely\n      // Return 0 to indicate unknown size\n      return 0;\n    }\n\n    // For other types, try to get length property\n    return body.length || body.size || 0;\n  }\n\n  /**\n   * Validate progress callback function\n   * @param {Function} callback - Progress callback to validate\n   * @throws {Error} If callback is not a valid function\n   */\n  validateProgressCallback(callback) {\n    if (callback !== undefined && typeof callback !== 'function') {\n      throw new Error('Progress callback must be a function');\n    }\n  }\n\n  /**\n   * Create a throttled progress callback to limit update frequency\n   * @param {Function} callback - Original progress callback\n   * @param {number} throttleMs - Throttle interval in milliseconds (default: 100ms)\n   * @returns {Function} Throttled progress callback\n   */\n  createThrottledProgressCallback(callback, throttleMs = 100) {\n    if (!callback || typeof callback !== 'function') {\n      return null;\n    }\n\n    let lastCallTime = 0;\n    let lastProgressEvent = null;\n\n    return (progressEvent) => {\n      const now = Date.now();\n\n      // Always call on first event or completion (100% progress)\n      if (\n        lastCallTime === 0 ||\n        progressEvent.progress >= 1 ||\n        now - lastCallTime >= throttleMs\n      ) {\n        lastCallTime = now;\n        lastProgressEvent = progressEvent;\n        callback(progressEvent);\n      } else {\n        // Store the latest event for potential final call\n        lastProgressEvent = progressEvent;\n      }\n    };\n  }\n}\n\nexport default ProgressHandler;\n","/**\n * HTTP Client using native fetch API\n * Provides axios-like interface for making HTTP requests\n */\n\nimport { HTTP_STATUS, DEFAULT_CONFIG, CONTENT_TYPES } from '../constants.js';\nimport { ProgressHandler } from './progress-handler.js';\n\nexport class HttpClient {\n  constructor(options = {}) {\n    this.timeout = options.timeout || DEFAULT_CONFIG.REQUEST_TIMEOUT;\n    this.baseURL = options.baseURL || '';\n    this.defaultHeaders = options.headers || {};\n    this.progressHandler = new ProgressHandler(options.progress || {});\n    \n    // Performance monitoring\n    this.performanceMetrics = {\n      enabled: options.enablePerformanceMetrics || false,\n      requestCount: 0,\n      totalRequestTime: 0,\n      averageRequestTime: 0,\n      slowRequests: [], // Track requests > 5 seconds\n      errorCount: 0\n    };\n  }\n\n  /**\n   * Start performance timing for a request\n   * @param {string} method - HTTP method\n   * @param {string} url - Request URL\n   * @returns {Object} Performance timer object\n   */\n  startPerformanceTimer(method, url) {\n    if (!this.performanceMetrics.enabled) {\n      return null;\n    }\n\n    return {\n      method,\n      url,\n      startTime: performance.now(),\n      startMemory: process.memoryUsage?.() || null\n    };\n  }\n\n  /**\n   * End performance timing and record metrics\n   * @param {Object} timer - Performance timer object\n   * @param {boolean} isError - Whether the request resulted in an error\n   */\n  endPerformanceTimer(timer, isError = false) {\n    if (!timer || !this.performanceMetrics.enabled) {\n      return;\n    }\n\n    const endTime = performance.now();\n    const duration = endTime - timer.startTime;\n    const endMemory = process.memoryUsage?.() || null;\n\n    // Update metrics\n    this.performanceMetrics.requestCount++;\n    this.performanceMetrics.totalRequestTime += duration;\n    this.performanceMetrics.averageRequestTime = \n      this.performanceMetrics.totalRequestTime / this.performanceMetrics.requestCount;\n\n    if (isError) {\n      this.performanceMetrics.errorCount++;\n    }\n\n    // Track slow requests (> 5 seconds)\n    if (duration > 5000) {\n      this.performanceMetrics.slowRequests.push({\n        method: timer.method,\n        url: timer.url,\n        duration,\n        timestamp: new Date().toISOString(),\n        memoryDelta: endMemory && timer.startMemory ? \n          endMemory.heapUsed - timer.startMemory.heapUsed : null\n      });\n\n      // Keep only last 10 slow requests\n      if (this.performanceMetrics.slowRequests.length > 10) {\n        this.performanceMetrics.slowRequests.shift();\n      }\n    }\n  }\n\n  /**\n   * Get performance metrics\n   * @returns {Object} Current performance metrics\n   */\n  getPerformanceMetrics() {\n    return { ...this.performanceMetrics };\n  }\n\n  /**\n   * Reset performance metrics\n   */\n  resetPerformanceMetrics() {\n    this.performanceMetrics = {\n      ...this.performanceMetrics,\n      requestCount: 0,\n      totalRequestTime: 0,\n      averageRequestTime: 0,\n      slowRequests: [],\n      errorCount: 0\n    };\n  }\n\n  /**\n   * Create an AbortController with timeout\n   * @param {number} timeout - Timeout in milliseconds\n   * @returns {AbortController}\n   */\n  createAbortController(timeout) {\n    const controller = new AbortController();\n\n    if (timeout > 0) {\n      setTimeout(() => {\n        controller.abort();\n      }, timeout);\n    }\n\n    return controller;\n  }\n\n  /**\n   * Transform fetch response to axios-like response format\n   * @param {Response} response - Fetch response object\n   * @param {any} data - Response data\n   * @returns {Object} Axios-like response object\n   */\n  transformResponse(response, data) {\n    return {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      data: data,\n      config: {\n        url: response.url,\n        method: response.method || 'GET',\n      },\n    };\n  }\n\n  /**\n   * Check if response should be streamed based on content length\n   * @param {Response} response - Fetch response object\n   * @param {string} responseType - Expected response type\n   * @returns {boolean} Whether to use streaming\n   */\n  shouldUseStreaming(response, responseType) {\n    const contentLength = response.headers.get('content-length');\n    const LARGE_FILE_THRESHOLD = 50 * 1024 * 1024; // 50MB\n    \n    // Use streaming for large files or when explicitly requested\n    return (\n      responseType === 'stream' ||\n      (contentLength && parseInt(contentLength) > LARGE_FILE_THRESHOLD) ||\n      response.headers.get('content-type')?.includes('application/octet-stream')\n    );\n  }\n\n  /**\n   * Optimize memory usage for large file uploads\n   * @param {any} data - Upload data\n   * @returns {any} Optimized data\n   */\n  optimizeUploadData(data) {\n    // For large ArrayBuffers, consider using streams (threshold: 10MB)\n    if (data instanceof ArrayBuffer && data.byteLength > 10 * 1024 * 1024) {\n      // Convert to ReadableStream for memory efficiency\n      return new ReadableStream({\n        start(controller) {\n          const chunk = new Uint8Array(data);\n          const chunkSize = 64 * 1024; // 64KB chunks\n          let offset = 0;\n          \n          const pump = () => {\n            if (offset < chunk.length) {\n              const end = Math.min(offset + chunkSize, chunk.length);\n              controller.enqueue(chunk.slice(offset, end));\n              offset = end;\n              // Use setTimeout to avoid blocking the event loop\n              setTimeout(pump, 0);\n            } else {\n              controller.close();\n            }\n          };\n          \n          pump();\n        }\n      });\n    }\n    \n    return data;\n  }\n\n  /**\n   * Parse response data based on content type and requested response type\n   * @param {Response} response - Fetch response object\n   * @param {string} responseType - Requested response type\n   * @returns {Promise<any>} Parsed response data\n   */\n  async parseResponseData(response, responseType = 'auto') {\n    // Use ProgressHandler for consistent response processing\n    return await this.progressHandler.processResponseWithoutProgress(\n      response,\n      responseType\n    );\n  }\n\n  /**\n   * Create error from fetch response\n   * @param {Response} response - Fetch response object\n   * @param {any} data - Response data\n   * @returns {Error} HTTP error\n   */\n  async createHttpError(response, data) {\n    const error = new Error(`HTTP ${response.status}: ${response.statusText}`);\n    error.status = response.status;\n    error.statusText = response.statusText;\n    error.response = this.transformResponse(response, data);\n    error.isHttpError = true;\n\n    // Add B2-specific error information if available\n    if (data && typeof data === 'object') {\n      if (data.code) {\n        error.code = data.code;\n      }\n      if (data.message) {\n        error.message = data.message;\n      }\n    }\n\n    return error;\n  }\n\n  /**\n   * Make HTTP request using fetch\n   * @param {Object} options - Request options\n   * @returns {Promise<Object>} Response object\n   */\n  async request(options = {}) {\n    const {\n      method = 'GET',\n      url,\n      data,\n      headers = {},\n      timeout = this.timeout,\n      responseType = 'auto',\n      onUploadProgress,\n      onDownloadProgress,\n    } = options;\n\n    // Start performance monitoring\n    const perfTimer = this.startPerformanceTimer(method, url);\n\n    // Validate progress callbacks\n    this.progressHandler.validateProgressCallback(onUploadProgress);\n    this.progressHandler.validateProgressCallback(onDownloadProgress);\n\n    // Construct full URL\n    const fullUrl = url.startsWith('http') ? url : `${this.baseURL}${url}`;\n\n    // Prepare headers\n    const requestHeaders = {\n      ...this.defaultHeaders,\n      ...headers,\n    };\n\n    // Prepare request body with progress tracking and memory optimization\n    let body = null;\n    if (data !== undefined && method !== 'GET' && method !== 'HEAD') {\n      if (\n        data instanceof FormData ||\n        data instanceof ArrayBuffer ||\n        data instanceof Blob\n      ) {\n        // Optimize large uploads for memory efficiency\n        body = this.optimizeUploadData(data);\n      } else if (typeof data === 'object') {\n        body = JSON.stringify(data);\n        if (!requestHeaders['Content-Type']) {\n          requestHeaders['Content-Type'] = CONTENT_TYPES.JSON;\n        }\n      } else {\n        body = data;\n      }\n\n      // Wrap body with upload progress tracking if callback provided\n      if (onUploadProgress && body) {\n        const bodySize = this.progressHandler.calculateBodySize(body);\n        const uploadTracker = this.progressHandler.createUploadProgressTracker(\n          onUploadProgress,\n          bodySize\n        );\n        if (uploadTracker) {\n          body = this.progressHandler.wrapUploadBody(body, uploadTracker);\n        }\n      }\n    }\n\n    // Create abort controller for timeout\n    const controller = this.createAbortController(timeout);\n\n    // Prepare fetch options\n    const fetchOptions = {\n      method: method.toUpperCase(),\n      headers: requestHeaders,\n      body,\n      signal: controller.signal,\n    };\n\n    try {\n      // Make the request\n      const response = await fetch(fullUrl, fetchOptions);\n\n      // Check if response is successful before processing\n      if (!response.ok) {\n        // For error responses, parse without progress tracking\n        const responseData = await this.parseResponseData(\n          response,\n          responseType\n        );\n        const error = await this.createHttpError(response, responseData);\n        throw error;\n      }\n\n      // Parse response data with progress tracking for downloads\n      const responseData =\n        await this.progressHandler.processResponseWithProgress(\n          response,\n          responseType,\n          onDownloadProgress\n        );\n\n      // End performance monitoring (success)\n      this.endPerformanceTimer(perfTimer, false);\n\n      // Return axios-like response\n      return this.transformResponse(response, responseData);\n    } catch (error) {\n      // End performance monitoring (error)\n      this.endPerformanceTimer(perfTimer, true);\n\n      // Handle fetch errors (network errors, timeouts, etc.)\n      if (error.name === 'AbortError') {\n        const timeoutError = new Error(`Request timeout after ${timeout}ms`);\n        timeoutError.code = 'TIMEOUT';\n        timeoutError.isNetworkError = true;\n        throw timeoutError;\n      }\n\n      if (error.isHttpError) {\n        // Re-throw HTTP errors as-is\n        throw error;\n      }\n\n      // Handle network errors\n      const networkError = new Error(`Network error: ${error.message}`);\n      networkError.code = 'NETWORK_ERROR';\n      networkError.isNetworkError = true;\n      networkError.originalError = error;\n      throw networkError;\n    }\n  }\n\n  /**\n   * Make GET request\n   * @param {string} url - Request URL\n   * @param {Object} options - Request options\n   * @returns {Promise<Object>} Response object\n   */\n  async get(url, options = {}) {\n    return this.request({\n      method: 'GET',\n      url,\n      ...options,\n    });\n  }\n\n  /**\n   * Make POST request\n   * @param {string} url - Request URL\n   * @param {any} data - Request data\n   * @param {Object} options - Request options\n   * @returns {Promise<Object>} Response object\n   */\n  async post(url, data, options = {}) {\n    return this.request({\n      method: 'POST',\n      url,\n      data,\n      ...options,\n    });\n  }\n\n  /**\n   * Make PUT request\n   * @param {string} url - Request URL\n   * @param {any} data - Request data\n   * @param {Object} options - Request options\n   * @returns {Promise<Object>} Response object\n   */\n  async put(url, data, options = {}) {\n    return this.request({\n      method: 'PUT',\n      url,\n      data,\n      ...options,\n    });\n  }\n\n  /**\n   * Make DELETE request\n   * @param {string} url - Request URL\n   * @param {Object} options - Request options\n   * @returns {Promise<Object>} Response object\n   */\n  async delete(url, options = {}) {\n    return this.request({\n      method: 'DELETE',\n      url,\n      ...options,\n    });\n  }\n}\n\nexport default HttpClient;","/**\n * Retry Handler with exponential backoff\n * Provides configurable retry logic for HTTP requests\n */\n\nimport {\n  DEFAULT_CONFIG,\n  RETRYABLE_STATUS_CODES,\n  RETRYABLE_ERROR_CODES,\n  HTTP_STATUS,\n} from '../constants.js';\n\nexport class RetryHandler {\n  constructor(options = {}) {\n    this.retries = options.retries ?? DEFAULT_CONFIG.RETRY_ATTEMPTS;\n    this.retryDelay = options.retryDelay ?? DEFAULT_CONFIG.RETRY_DELAY;\n    this.retryDelayMultiplier =\n      options.retryDelayMultiplier ?? DEFAULT_CONFIG.RETRY_DELAY_MULTIPLIER;\n    this.maxRetryDelay =\n      options.maxRetryDelay ?? DEFAULT_CONFIG.MAX_RETRY_DELAY;\n    this.retryCondition =\n      options.retryCondition || this.defaultRetryCondition.bind(this);\n    this.onRetry = options.onRetry || null;\n  }\n\n  /**\n   * Default retry condition - determines if an error should trigger a retry\n   * @param {Error} error - The error that occurred\n   * @param {number} attempt - Current attempt number (0-based)\n   * @returns {boolean} Whether to retry the request\n   */\n  defaultRetryCondition(error, attempt) {\n    // Don't retry if we've exceeded max attempts\n    if (attempt >= this.retries) {\n      return false;\n    }\n\n    // Retry network errors (connection failures, timeouts)\n    if (error.isNetworkError) {\n      return true;\n    }\n\n    // Retry specific HTTP status codes\n    if (error.status && RETRYABLE_STATUS_CODES.has(error.status)) {\n      return true;\n    }\n\n    // Retry specific B2 error codes\n    if (error.code && RETRYABLE_ERROR_CODES.has(error.code)) {\n      return true;\n    }\n\n    // Don't retry client errors (4xx except 429)\n    if (\n      error.status >= 400 &&\n      error.status < 500 &&\n      error.status !== HTTP_STATUS.TOO_MANY_REQUESTS\n    ) {\n      return false;\n    }\n\n    // Retry server errors (5xx)\n    if (error.status >= 500) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Calculate delay for next retry attempt with exponential backoff and jitter\n   * @param {number} attempt - Current attempt number (0-based)\n   * @returns {number} Delay in milliseconds\n   */\n  calculateDelay(attempt) {\n    // Calculate exponential backoff: baseDelay * (multiplier ^ attempt)\n    const exponentialDelay =\n      this.retryDelay * Math.pow(this.retryDelayMultiplier, attempt);\n\n    // Apply maximum delay limit\n    const cappedDelay = Math.min(exponentialDelay, this.maxRetryDelay);\n\n    // Add jitter (±25% of the delay) to avoid thundering herd\n    const jitterRange = cappedDelay * 0.25;\n    const jitter = (Math.random() - 0.5) * 2 * jitterRange;\n\n    return Math.max(0, Math.round(cappedDelay + jitter));\n  }\n\n  /**\n   * Sleep for specified duration\n   * @param {number} ms - Milliseconds to sleep\n   * @returns {Promise<void>}\n   */\n  sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Execute a function with retry logic\n   * @param {Function} requestFn - Function that returns a Promise\n   * @param {Object} options - Retry options\n   * @returns {Promise<any>} Result of successful request\n   */\n  async executeWithRetry(requestFn, options = {}) {\n    const maxAttempts = (options.retries ?? this.retries) + 1; // +1 for initial attempt\n    let lastError;\n\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        // Execute the request function\n        const result = await requestFn();\n        return result;\n      } catch (error) {\n        lastError = error;\n\n        // Check if we should retry this error\n        const shouldRetry = this.retryCondition(error, attempt);\n\n        // If this is the last attempt or we shouldn't retry, throw the error\n        if (attempt === maxAttempts - 1 || !shouldRetry) {\n          // Add retry information to the error\n          error.retryAttempts = attempt + 1;\n          error.isRetryExhausted = attempt === maxAttempts - 1;\n          throw error;\n        }\n\n        // Calculate delay for next attempt\n        const delay = this.calculateDelay(attempt);\n\n        // Call onRetry callback if provided\n        if (this.onRetry) {\n          this.onRetry(error, attempt + 1, delay);\n        }\n\n        // Wait before next attempt\n        if (delay > 0) {\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    // This should never be reached, but just in case\n    throw lastError;\n  }\n\n  /**\n   * Create a retry wrapper for a function\n   * @param {Function} fn - Function to wrap with retry logic\n   * @param {Object} options - Retry options\n   * @returns {Function} Wrapped function with retry logic\n   */\n  wrap(fn, options = {}) {\n    return (...args) => {\n      return this.executeWithRetry(() => fn(...args), options);\n    };\n  }\n\n  /**\n   * Check if an error is retryable\n   * @param {Error} error - Error to check\n   * @returns {boolean} Whether the error is retryable\n   */\n  isRetryable(error) {\n    return this.retryCondition(error, 0);\n  }\n\n  /**\n   * Get retry configuration\n   * @returns {Object} Current retry configuration\n   */\n  getConfig() {\n    return {\n      retries: this.retries,\n      retryDelay: this.retryDelay,\n      retryDelayMultiplier: this.retryDelayMultiplier,\n      maxRetryDelay: this.maxRetryDelay,\n    };\n  }\n\n  /**\n   * Update retry configuration\n   * @param {Object} options - New retry options\n   */\n  updateConfig(options = {}) {\n    if (options.retries !== undefined) this.retries = options.retries;\n    if (options.retryDelay !== undefined) this.retryDelay = options.retryDelay;\n    if (options.retryDelayMultiplier !== undefined)\n      this.retryDelayMultiplier = options.retryDelayMultiplier;\n    if (options.maxRetryDelay !== undefined)\n      this.maxRetryDelay = options.maxRetryDelay;\n    if (options.retryCondition !== undefined)\n      this.retryCondition = options.retryCondition;\n    if (options.onRetry !== undefined) this.onRetry = options.onRetry;\n  }\n}\n\nexport default RetryHandler;\n","import { HEADERS, CONTENT_TYPES } from '../constants.js';\n\n/**\n * Utility class for constructing HTTP headers for B2 API requests\n */\nexport class HeaderBuilder {\n  constructor() {\n    this.headers = {};\n  }\n\n  /**\n   * Reset headers to empty state\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  reset() {\n    this.headers = {};\n    return this;\n  }\n\n  /**\n   * Set a header value\n   * @param {string} name - Header name\n   * @param {string} value - Header value\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setHeader(name, value) {\n    if (value !== undefined && value !== null) {\n      this.headers[name] = String(value);\n    }\n    return this;\n  }\n\n  /**\n   * Set multiple headers from an object\n   * @param {Object} headers - Object containing header key-value pairs\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setHeaders(headers) {\n    if (headers && typeof headers === 'object') {\n      Object.entries(headers).forEach(([name, value]) => {\n        this.setHeader(name, value);\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Set Content-Type header\n   * @param {string} contentType - Content type value\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setContentType(contentType) {\n    return this.setHeader(HEADERS.CONTENT_TYPE, contentType);\n  }\n\n  /**\n   * Set Content-Length header\n   * @param {number} contentLength - Content length in bytes\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setContentLength(contentLength) {\n    return this.setHeader(HEADERS.CONTENT_LENGTH, contentLength);\n  }\n\n  /**\n   * Set Authorization header\n   * @param {string} token - Authorization token\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setAuthorization(token) {\n    return this.setHeader(HEADERS.AUTHORIZATION, token);\n  }\n\n  /**\n   * Set Basic Authorization header\n   * @param {string} applicationKeyId - Application key ID\n   * @param {string} applicationKey - Application key\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setBasicAuth(applicationKeyId, applicationKey) {\n    const credentials = btoa(`${applicationKeyId}:${applicationKey}`);\n    return this.setAuthorization(`Basic ${credentials}`);\n  }\n\n  /**\n   * Set Bearer Authorization header\n   * @param {string} token - Bearer token\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setBearerAuth(token) {\n    return this.setAuthorization(token);\n  }\n\n  /**\n   * Set file-related headers\n   * @param {Object} options - File options\n   * @param {string} options.fileName - File name\n   * @param {string} options.contentSha1 - SHA1 hash of content\n   * @param {string} options.contentType - Content type\n   * @param {number} options.contentLength - Content length\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setFileHeaders({ fileName, contentSha1, contentType, contentLength }) {\n    if (fileName) {\n      this.setHeader(HEADERS.FILE_NAME, encodeURIComponent(fileName));\n    }\n    if (contentSha1) {\n      this.setHeader(HEADERS.CONTENT_SHA1, contentSha1);\n    }\n    if (contentType) {\n      this.setContentType(contentType);\n    }\n    if (contentLength !== undefined) {\n      this.setContentLength(contentLength);\n    }\n    return this;\n  }\n\n  /**\n   * Set part number header for multipart uploads\n   * @param {number} partNumber - Part number (1-based)\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setPartNumber(partNumber) {\n    return this.setHeader(HEADERS.PART_NUMBER, partNumber);\n  }\n\n  /**\n   * Set test mode header\n   * @param {boolean} testMode - Whether to enable test mode\n   * @returns {HeaderBuilder} This instance for chaining\n   */\n  setTestMode(testMode = true) {\n    if (testMode) {\n      this.setHeader(HEADERS.TEST_MODE, 'fail_some_uploads');\n    }\n    return this;\n  }\n\n  /**\n   * Get the built headers object\n   * @returns {Object} Headers object\n   */\n  build() {\n    return { ...this.headers };\n  }\n}\n\n/**\n * Authentication header utilities\n */\nexport const AuthHeaders = {\n  /**\n   * Create Basic authentication header\n   * @param {string} applicationKeyId - Application key ID\n   * @param {string} applicationKey - Application key\n   * @returns {Object} Headers object with Authorization header\n   */\n  createBasicAuth(applicationKeyId, applicationKey) {\n    if (!applicationKeyId || !applicationKey) {\n      throw new Error(\n        'Application key ID and application key are required for Basic auth'\n      );\n    }\n\n    const credentials = btoa(`${applicationKeyId}:${applicationKey}`);\n    return {\n      [HEADERS.AUTHORIZATION]: `Basic ${credentials}`,\n    };\n  },\n\n  /**\n   * Create Bearer authentication header\n   * @param {string} token - Bearer token\n   * @returns {Object} Headers object with Authorization header\n   */\n  createBearerAuth(token) {\n    if (!token) {\n      throw new Error('Token is required for Bearer auth');\n    }\n\n    return {\n      [HEADERS.AUTHORIZATION]: token,\n    };\n  },\n\n  /**\n   * Extract authorization token from headers\n   * @param {Object} headers - Headers object\n   * @returns {string|null} Authorization token or null if not found\n   */\n  extractAuthToken(headers) {\n    return headers?.[HEADERS.AUTHORIZATION] || null;\n  },\n};\n\n/**\n * Info header utilities for file metadata\n */\nexport const InfoHeaders = {\n  /**\n   * Maximum number of info headers allowed by B2\n   */\n  MAX_INFO_HEADERS: 10,\n\n  /**\n   * Add info headers to existing headers object\n   * @param {Object} headers - Existing headers object\n   * @param {Object} info - Info object with metadata\n   * @returns {Object} Updated headers object\n   */\n  addInfoHeaders(headers, info) {\n    if (!info || typeof info !== 'object') {\n      return headers;\n    }\n\n    const keys = Object.keys(info);\n\n    if (keys.length > this.MAX_INFO_HEADERS) {\n      throw new Error(\n        `Too many info headers: maximum of ${this.MAX_INFO_HEADERS} allowed`\n      );\n    }\n\n    const invalidKeys = [];\n    const updatedHeaders = { ...headers };\n\n    keys.forEach((key) => {\n      if (this.isValidInfoHeaderKey(key)) {\n        const headerName = `X-Bz-Info-${key}`;\n        updatedHeaders[headerName] = encodeURIComponent(String(info[key]));\n      } else {\n        invalidKeys.push(key);\n      }\n    });\n\n    if (invalidKeys.length > 0) {\n      throw new Error(\n        `Info header keys contain invalid characters: ${invalidKeys.join(', ')}`\n      );\n    }\n\n    return updatedHeaders;\n  },\n\n  /**\n   * Validate info header key\n   * @param {string} key - Header key to validate\n   * @returns {boolean} True if valid\n   */\n  isValidInfoHeaderKey(key) {\n    return typeof key === 'string' && /^[a-zA-Z0-9\\-_]+$/.test(key);\n  },\n\n  /**\n   * Extract info headers from response headers\n   * @param {Object} headers - Response headers\n   * @returns {Object} Extracted info headers\n   */\n  extractInfoHeaders(headers) {\n    const info = {};\n\n    if (!headers || typeof headers !== 'object') {\n      return info;\n    }\n\n    Object.entries(headers).forEach(([key, value]) => {\n      if (key.toLowerCase().startsWith('x-bz-info-')) {\n        const infoKey = key.substring(10); // Remove 'x-bz-info-' prefix (10 characters)\n        try {\n          info[infoKey] = decodeURIComponent(value);\n        } catch (error) {\n          // If decoding fails, use the raw value\n          info[infoKey] = value;\n        }\n      }\n    });\n\n    return info;\n  },\n};\n\n/**\n * Common header utilities\n */\nexport const HeaderUtils = {\n  /**\n   * Create headers for JSON requests\n   * @param {string} authToken - Authorization token\n   * @returns {Object} Headers object\n   */\n  createJsonHeaders(authToken) {\n    const headers = {\n      [HEADERS.CONTENT_TYPE]: CONTENT_TYPES.JSON,\n    };\n\n    if (authToken) {\n      headers[HEADERS.AUTHORIZATION] = authToken;\n    }\n\n    return headers;\n  },\n\n  /**\n   * Create headers for file upload\n   * @param {Object} options - Upload options\n   * @param {string} options.authToken - Authorization token\n   * @param {string} options.fileName - File name\n   * @param {string} options.contentType - Content type\n   * @param {string} options.contentSha1 - SHA1 hash\n   * @param {number} options.contentLength - Content length\n   * @param {Object} options.info - File info metadata\n   * @returns {Object} Headers object\n   */\n  createUploadHeaders({\n    authToken,\n    fileName,\n    contentType,\n    contentSha1,\n    contentLength,\n    info,\n  }) {\n    let headers = {};\n\n    if (authToken) {\n      headers[HEADERS.AUTHORIZATION] = authToken;\n    }\n\n    if (fileName) {\n      headers[HEADERS.FILE_NAME] = encodeURIComponent(fileName);\n    }\n\n    if (contentType) {\n      headers[HEADERS.CONTENT_TYPE] = contentType;\n    }\n\n    if (contentSha1) {\n      headers[HEADERS.CONTENT_SHA1] = contentSha1;\n    }\n\n    if (contentLength !== undefined) {\n      headers[HEADERS.CONTENT_LENGTH] = String(contentLength);\n    }\n\n    // Add info headers if provided\n    if (info) {\n      headers = InfoHeaders.addInfoHeaders(headers, info);\n    }\n\n    return headers;\n  },\n\n  /**\n   * Create headers for part upload\n   * @param {Object} options - Part upload options\n   * @param {string} options.authToken - Authorization token\n   * @param {number} options.partNumber - Part number\n   * @param {string} options.contentSha1 - SHA1 hash of part\n   * @param {number} options.contentLength - Content length\n   * @returns {Object} Headers object\n   */\n  createPartUploadHeaders({\n    authToken,\n    partNumber,\n    contentSha1,\n    contentLength,\n  }) {\n    const headers = {};\n\n    if (authToken) {\n      headers[HEADERS.AUTHORIZATION] = authToken;\n    }\n\n    if (partNumber !== undefined) {\n      headers[HEADERS.PART_NUMBER] = String(partNumber);\n    }\n\n    if (contentSha1) {\n      headers[HEADERS.CONTENT_SHA1] = contentSha1;\n    }\n\n    if (contentLength !== undefined) {\n      headers[HEADERS.CONTENT_LENGTH] = String(contentLength);\n    }\n\n    return headers;\n  },\n\n  /**\n   * Normalize header names to lowercase\n   * @param {Object} headers - Headers object\n   * @returns {Object} Normalized headers object\n   */\n  normalizeHeaders(headers) {\n    if (!headers || typeof headers !== 'object') {\n      return {};\n    }\n\n    const normalized = {};\n    Object.entries(headers).forEach(([key, value]) => {\n      normalized[key.toLowerCase()] = value;\n    });\n\n    return normalized;\n  },\n\n  /**\n   * Convert B2 response headers to camelCase object\n   * @param {Object} headers - Response headers\n   * @returns {Object} Converted headers object\n   */\n  convertBzHeaders(headers) {\n    const result = {};\n\n    if (!headers || typeof headers !== 'object') {\n      return result;\n    }\n\n    Object.entries(headers).forEach(([key, value]) => {\n      if (key.toLowerCase().startsWith('x-bz-')) {\n        let camelKey;\n\n        if (key.toLowerCase().startsWith('x-bz-info-')) {\n          // Handle info headers specially\n          camelKey = 'info' + this.toCamelCase(key.substring(11));\n        } else {\n          // Handle other B2 headers\n          camelKey = this.toCamelCase(key.substring(5)); // Remove 'x-bz-' prefix\n        }\n\n        result[camelKey] = value;\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * Convert kebab-case to camelCase\n   * @param {string} str - String to convert\n   * @returns {string} CamelCase string\n   */\n  toCamelCase(str) {\n    return str\n      .split('-')\n      .map((word, index) => {\n        if (index === 0) {\n          return word.toLowerCase();\n        }\n        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n      })\n      .join('');\n  },\n};\n\n// Create a default header builder instance for convenience\nexport const headerBuilder = new HeaderBuilder();\n","/**\n * Authentication Manager for B2 API\n * Handles credential validation, authorization, and auth context management\n */\n\nimport {\n  API_ENDPOINTS,\n  B2_API_BASE_URL,\n  B2_ERROR_CODES,\n} from '../constants.js';\nimport { AuthHeaders } from '../utils/headers.js';\nimport { Validator } from '../utils/validation.js';\n\nexport class AuthManager {\n  constructor(httpClient, config = {}) {\n    this.httpClient = httpClient;\n    this.config = config;\n\n    // Auth context storage\n    this.authContext = {\n      authorizationToken: null,\n      apiUrl: null,\n      downloadUrl: null,\n      accountId: null,\n      recommendedPartSize: null,\n      absoluteMinimumPartSize: null,\n      allowed: null,\n      isAuthenticated: false,\n    };\n  }\n\n  /**\n   * Validate credentials for authentication\n   * @param {Object} credentials - Authentication credentials\n   * @param {string} credentials.applicationKeyId - Application key ID\n   * @param {string} credentials.applicationKey - Application key\n   * @throws {Error} If credentials are invalid\n   */\n  validateCredentials(credentials) {\n    if (!credentials || typeof credentials !== 'object') {\n      throw new Error('credentials is required');\n    }\n\n    if (!credentials.hasOwnProperty('applicationKeyId')) {\n      throw new Error('applicationKeyId is required');\n    }\n\n    if (!credentials.hasOwnProperty('applicationKey')) {\n      throw new Error('applicationKey is required');\n    }\n\n    if (typeof credentials.applicationKeyId !== 'string') {\n      throw new Error('applicationKeyId must be a string');\n    }\n\n    if (typeof credentials.applicationKey !== 'string') {\n      throw new Error('applicationKey must be a string');\n    }\n\n    if (credentials.applicationKeyId.trim().length === 0) {\n      throw new Error('Application key ID cannot be empty');\n    }\n\n    if (credentials.applicationKey.trim().length === 0) {\n      throw new Error('Application key cannot be empty');\n    }\n  }\n\n  /**\n   * Generate Basic authentication header\n   * @param {string} applicationKeyId - Application key ID\n   * @param {string} applicationKey - Application key\n   * @returns {Object} Headers object with Basic auth\n   */\n  generateBasicAuthHeader(applicationKeyId, applicationKey) {\n    try {\n      return AuthHeaders.createBasicAuth(applicationKeyId, applicationKey);\n    } catch (error) {\n      throw new Error(`Failed to generate Basic auth header: ${error.message}`);\n    }\n  }\n\n  /**\n   * Save authentication context from API response\n   * @param {Object} authResponse - Authentication response from B2 API\n   */\n  saveAuthContext(authResponse) {\n    if (!authResponse || typeof authResponse !== 'object') {\n      throw new Error('Invalid authentication response');\n    }\n\n    // Handle both old and new B2 API response formats\n    let apiUrl, downloadUrl, recommendedPartSize, absoluteMinimumPartSize, allowed;\n\n    // New format: nested in apiInfo.storageApi\n    if (authResponse.apiInfo && authResponse.apiInfo.storageApi) {\n      const storageApi = authResponse.apiInfo.storageApi;\n      apiUrl = storageApi.apiUrl;\n      downloadUrl = storageApi.downloadUrl;\n      recommendedPartSize = storageApi.recommendedPartSize;\n      absoluteMinimumPartSize = storageApi.absoluteMinimumPartSize; \n      allowed = storageApi.allowed;\n    }\n    // Old format: fields at root level (for backward compatibility)\n    else {\n      apiUrl = authResponse.apiUrl;\n      downloadUrl = authResponse.downloadUrl;\n      recommendedPartSize = authResponse.recommendedPartSize;\n      absoluteMinimumPartSize = authResponse.absoluteMinimumPartSize;\n      allowed = authResponse.allowed;\n    }\n\n    // Validate required fields\n    const requiredFields = [\n      { name: 'authorizationToken', value: authResponse.authorizationToken },\n      { name: 'apiUrl', value: apiUrl },\n      { name: 'downloadUrl', value: downloadUrl },\n      { name: 'accountId', value: authResponse.accountId },\n    ];\n\n    for (const field of requiredFields) {\n      if (!field.value) {\n        throw new Error(`Missing required field in auth response: ${field.name}`);\n      }\n    }\n\n    this.authContext = {\n      authorizationToken: authResponse.authorizationToken,\n      apiUrl: apiUrl,\n      downloadUrl: downloadUrl,\n      accountId: authResponse.accountId,\n      recommendedPartSize: recommendedPartSize || null,\n      absoluteMinimumPartSize: absoluteMinimumPartSize || null,\n      allowed: allowed || null,\n      isAuthenticated: true,\n    };\n  }\n\n  /**\n   * Get current authentication context\n   * @returns {Object} Current auth context\n   */\n  getAuthContext() {\n    return { ...this.authContext };\n  }\n\n  /**\n   * Check if currently authenticated\n   * @returns {boolean} True if authenticated\n   */\n  isAuthenticated() {\n    return (\n      this.authContext.isAuthenticated && !!this.authContext.authorizationToken\n    );\n  }\n\n  /**\n   * Get authorization token for authenticated requests\n   * @returns {string|null} Authorization token or null if not authenticated\n   */\n  getAuthToken() {\n    return this.authContext.authorizationToken;\n  }\n\n  /**\n   * Get API URL for making authenticated requests\n   * @returns {string|null} API URL or null if not authenticated\n   */\n  getApiUrl() {\n    return this.authContext.apiUrl;\n  }\n\n  /**\n   * Get download URL for file downloads\n   * @returns {string|null} Download URL or null if not authenticated\n   */\n  getDownloadUrl() {\n    return this.authContext.downloadUrl;\n  }\n\n  /**\n   * Get account ID\n   * @returns {string|null} Account ID or null if not authenticated\n   */\n  getAccountId() {\n    return this.authContext.accountId;\n  }\n\n  /**\n   * Get recommended part size for large file uploads\n   * @returns {number|null} Recommended part size or null if not available\n   */\n  getRecommendedPartSize() {\n    return this.authContext.recommendedPartSize;\n  }\n\n  /**\n   * Clear authentication context\n   */\n  clearAuthContext() {\n    this.authContext = {\n      authorizationToken: null,\n      apiUrl: null,\n      downloadUrl: null,\n      accountId: null,\n      recommendedPartSize: null,\n      absoluteMinimumPartSize: null,\n      allowed: null,\n      isAuthenticated: false,\n    };\n  }\n\n  /**\n   * Authorize with B2 API using application credentials\n   * @param {Object} credentials - Authentication credentials\n   * @param {string} credentials.applicationKeyId - Application key ID\n   * @param {string} credentials.applicationKey - Application key\n   * @param {Object} options - Additional options\n   * @returns {Promise<Object>} Authentication response\n   */\n  async authorize(credentials, options = {}) {\n    // Validate credentials\n    this.validateCredentials(credentials);\n\n    // Generate Basic auth header\n    const authHeaders = this.generateBasicAuthHeader(\n      credentials.applicationKeyId,\n      credentials.applicationKey\n    );\n\n    try {\n      // Make authorization request\n      const response = await this.httpClient.get(\n        `${B2_API_BASE_URL}${API_ENDPOINTS.AUTHORIZE_ACCOUNT}`,\n        {\n          headers: authHeaders,\n          timeout: options.timeout,\n        }\n      );\n\n      // Save auth context from response\n      this.saveAuthContext(response.data);\n\n      return response;\n    } catch (error) {\n      // Clear any existing auth context on failure\n      this.clearAuthContext();\n\n      // Handle specific B2 authentication errors\n      if (error.status === 401) {\n        const b2Error = new Error(\n          'Authentication failed: Invalid application key ID or application key'\n        );\n        b2Error.code = B2_ERROR_CODES.BAD_AUTH_TOKEN;\n        b2Error.status = 401;\n        b2Error.isAuthError = true;\n        // Preserve original response for compatibility\n        b2Error.response = error.response;\n        throw b2Error;\n      }\n\n      // Re-throw other errors\n      throw error;\n    }\n  }\n\n  /**\n   * Get headers for authenticated requests\n   * @returns {Object} Headers object with authorization token\n   * @throws {Error} If not authenticated\n   */\n  getAuthHeaders() {\n    if (!this.isAuthenticated()) {\n      throw new Error('Not authenticated. Call authorize() first.');\n    }\n\n    return AuthHeaders.createBearerAuth(this.authContext.authorizationToken);\n  }\n\n  /**\n   * Refresh authentication if token is expired\n   * @param {Object} credentials - Original credentials for re-authentication\n   * @param {Object} options - Additional options\n   * @returns {Promise<Object>} New authentication response\n   */\n  async refreshAuth(credentials, options = {}) {\n    // Clear current context and re-authenticate\n    this.clearAuthContext();\n    return this.authorize(credentials, options);\n  }\n\n  /**\n   * Check if an error indicates expired authentication\n   * @param {Error} error - Error to check\n   * @returns {boolean} True if error indicates expired auth\n   */\n  isAuthExpiredError(error) {\n    return (\n      error.status === 401 ||\n      error.code === B2_ERROR_CODES.BAD_AUTH_TOKEN ||\n      error.code === B2_ERROR_CODES.EXPIRED_AUTH_TOKEN\n    );\n  }\n}\n\nexport default AuthManager;\n","import { B2_API_BASE_URL, API_ENDPOINTS } from '../constants.js';\n\n/**\n * Utility class for constructing B2 API endpoint URLs\n */\nexport class EndpointBuilder {\n  constructor(authContext = null) {\n    this.authContext = authContext;\n  }\n\n  /**\n   * Update the auth context for dynamic URL construction\n   * @param {Object} authContext - Authentication context containing apiUrl and downloadUrl\n   */\n  setAuthContext(authContext) {\n    this.authContext = authContext;\n  }\n\n  /**\n   * Get the base API URL (either from auth context or default)\n   * @returns {string} Base API URL\n   */\n  getApiUrl() {\n    return this.authContext?.apiUrl || B2_API_BASE_URL;\n  }\n\n  /**\n   * Get the download URL from auth context\n   * @returns {string} Download URL\n   */\n  getDownloadUrl() {\n    if (!this.authContext?.downloadUrl) {\n      throw new Error('Download URL not available. Please authenticate first.');\n    }\n    return this.authContext.downloadUrl;\n  }\n\n  /**\n   * Build a complete API endpoint URL\n   * @param {string} endpoint - The endpoint path from API_ENDPOINTS\n   * @param {Object} params - Optional query parameters\n   * @returns {string} Complete URL\n   */\n  buildApiUrl(endpoint, params = {}) {\n    const baseUrl = this.getApiUrl();\n    const url = new URL(endpoint, baseUrl);\n\n    // Add query parameters\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        url.searchParams.append(key, String(value));\n      }\n    });\n\n    return url.toString();\n  }\n\n  /**\n   * Build a download URL\n   * @param {string} endpoint - The download endpoint path\n   * @param {Object} params - Optional query parameters\n   * @returns {string} Complete download URL\n   */\n  buildDownloadUrl(endpoint, params = {}) {\n    const baseUrl = this.getDownloadUrl();\n    const url = new URL(endpoint, baseUrl);\n\n    // Add query parameters\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        url.searchParams.append(key, String(value));\n      }\n    });\n\n    return url.toString();\n  }\n\n  // Authentication endpoints\n  getAuthorizeAccountUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.AUTHORIZE_ACCOUNT);\n  }\n\n  // Bucket endpoints\n  getCreateBucketUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.CREATE_BUCKET);\n  }\n\n  getDeleteBucketUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.DELETE_BUCKET);\n  }\n\n  getListBucketsUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.LIST_BUCKETS);\n  }\n\n  getUpdateBucketUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.UPDATE_BUCKET);\n  }\n\n  getUploadUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.GET_UPLOAD_URL);\n  }\n\n  // File endpoints\n  getListFileNamesUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.LIST_FILE_NAMES);\n  }\n\n  getListFileVersionsUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.LIST_FILE_VERSIONS);\n  }\n\n  getFileInfoUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.GET_FILE_INFO);\n  }\n\n  getDeleteFileVersionUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.DELETE_FILE_VERSION);\n  }\n\n  getHideFileUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.HIDE_FILE);\n  }\n\n  /**\n   * Get download file by name URL\n   * @param {string} bucketName - The bucket name\n   * @param {string} fileName - The file name (will be URL encoded)\n   * @returns {string} Download URL\n   */\n  getDownloadFileByNameUrl(bucketName, fileName) {\n    const encodedFileName = encodeURIComponent(fileName);\n    const endpoint = `${API_ENDPOINTS.DOWNLOAD_FILE_BY_NAME}/${encodeURIComponent(bucketName)}/${encodedFileName}`;\n    return this.buildDownloadUrl(endpoint);\n  }\n\n  /**\n   * Get download file by ID URL\n   * @param {string} fileId - The file ID\n   * @returns {string} Download URL\n   */\n  getDownloadFileByIdUrl(fileId) {\n    return this.buildDownloadUrl(API_ENDPOINTS.DOWNLOAD_FILE_BY_ID, { fileId });\n  }\n\n  // Large file endpoints\n  getStartLargeFileUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.START_LARGE_FILE);\n  }\n\n  getUploadPartUrlEndpoint() {\n    return this.buildApiUrl(API_ENDPOINTS.GET_UPLOAD_PART_URL);\n  }\n\n  getFinishLargeFileUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.FINISH_LARGE_FILE);\n  }\n\n  getCancelLargeFileUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.CANCEL_LARGE_FILE);\n  }\n\n  getListPartsUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.LIST_PARTS);\n  }\n\n  getListUnfinishedLargeFilesUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.LIST_UNFINISHED_LARGE_FILES);\n  }\n\n  // Key management endpoints\n  getCreateKeyUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.CREATE_KEY);\n  }\n\n  getDeleteKeyUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.DELETE_KEY);\n  }\n\n  getListKeysUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.LIST_KEYS);\n  }\n\n  // Download authorization\n  getDownloadAuthorizationUrl() {\n    return this.buildApiUrl(API_ENDPOINTS.GET_DOWNLOAD_AUTHORIZATION);\n  }\n}\n\n/**\n * URL encoding utilities for file names and parameters\n */\nexport const UrlUtils = {\n  /**\n   * Encode a file name for use in URLs\n   * @param {string} fileName - The file name to encode\n   * @returns {string} URL-encoded file name\n   */\n  encodeFileName(fileName) {\n    if (typeof fileName !== 'string') {\n      throw new Error('File name must be a string');\n    }\n    return encodeURIComponent(fileName);\n  },\n\n  /**\n   * Encode a bucket name for use in URLs\n   * @param {string} bucketName - The bucket name to encode\n   * @returns {string} URL-encoded bucket name\n   */\n  encodeBucketName(bucketName) {\n    if (typeof bucketName !== 'string') {\n      throw new Error('Bucket name must be a string');\n    }\n    return encodeURIComponent(bucketName);\n  },\n\n  /**\n   * Encode query parameters for URLs\n   * @param {Object} params - Object containing key-value pairs\n   * @returns {string} URL-encoded query string\n   */\n  encodeQueryParams(params) {\n    if (!params || typeof params !== 'object') {\n      return '';\n    }\n\n    const searchParams = new URLSearchParams();\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        searchParams.append(key, String(value));\n      }\n    });\n\n    const queryString = searchParams.toString();\n    return queryString ? `?${queryString}` : '';\n  },\n\n  /**\n   * Validate and encode a file path for B2\n   * @param {string} filePath - The file path to validate and encode\n   * @returns {string} Validated and encoded file path\n   */\n  validateAndEncodeFilePath(filePath) {\n    if (typeof filePath !== 'string') {\n      throw new Error('File path must be a string');\n    }\n\n    if (filePath.length === 0) {\n      throw new Error('File path cannot be empty');\n    }\n\n    if (filePath.length > 1024) {\n      throw new Error('File path cannot exceed 1024 characters');\n    }\n\n    // B2 doesn't allow certain characters in file names\n    const invalidChars = /[\\x00-\\x1f\\x7f]/;\n    if (invalidChars.test(filePath)) {\n      throw new Error('File path contains invalid characters');\n    }\n\n    return encodeURIComponent(filePath);\n  },\n};\n\n// Create a default instance for convenience\nexport const endpoints = new EndpointBuilder();\n\n// Export individual functions for backward compatibility\nexport const buildApiUrl = (endpoint, params, authContext) => {\n  const builder = new EndpointBuilder(authContext);\n  return builder.buildApiUrl(endpoint, params);\n};\n\nexport const buildDownloadUrl = (endpoint, params, authContext) => {\n  const builder = new EndpointBuilder(authContext);\n  return builder.buildDownloadUrl(endpoint, params);\n};\n","/**\n * Bucket Manager for B2 API\n * Handles bucket CRUD operations and upload URL generation\n */\n\nimport { BUCKET_TYPES, B2_ERROR_CODES } from '../constants.js';\nimport { Validator } from '../utils/validation.js';\nimport { EndpointBuilder } from '../utils/endpoints.js';\n\nexport class BucketManager {\n  constructor(httpClient, authManager, config = {}) {\n    this.httpClient = httpClient;\n    this.authManager = authManager;\n    this.config = config;\n    this.endpointBuilder = new EndpointBuilder();\n  }\n\n  /**\n   * Validate bucket name according to B2 requirements\n   * @param {string} bucketName - Bucket name to validate\n   * @throws {Error} If bucket name is invalid\n   */\n  validateBucketName(bucketName) {\n    if (!bucketName || typeof bucketName !== 'string') {\n      throw new Error('bucketName is required and must be a string');\n    }\n\n    if (bucketName.length < 6 || bucketName.length > 50) {\n      throw new Error('Bucket name must be between 6 and 50 characters');\n    }\n\n    // B2 bucket name requirements\n    const validPattern = /^[a-z0-9][a-z0-9\\-]*[a-z0-9]$/;\n    if (!validPattern.test(bucketName)) {\n      throw new Error(\n        'Bucket name must start and end with alphanumeric characters and contain only lowercase letters, numbers, and hyphens'\n      );\n    }\n\n    // Cannot contain consecutive hyphens\n    if (bucketName.includes('--')) {\n      throw new Error('Bucket name cannot contain consecutive hyphens');\n    }\n  }\n\n  /**\n   * Validate bucket type\n   * @param {string} bucketType - Bucket type to validate\n   * @throws {Error} If bucket type is invalid\n   */\n  validateBucketType(bucketType) {\n    if (!bucketType || typeof bucketType !== 'string') {\n      throw new Error('bucketType is required and must be a string');\n    }\n\n    const validTypes = Object.values(BUCKET_TYPES);\n    if (!validTypes.includes(bucketType)) {\n      throw new Error(\n        `Invalid bucket type. Must be one of: ${validTypes.join(', ')}`\n      );\n    }\n  }\n\n  /**\n   * Validate bucket ID\n   * @param {string} bucketId - Bucket ID to validate\n   * @throws {Error} If bucket ID is invalid\n   */\n  validateBucketId(bucketId) {\n    if (!bucketId || typeof bucketId !== 'string') {\n      throw new Error('bucketId is required and must be a string');\n    }\n\n    if (bucketId.trim().length === 0) {\n      throw new Error('bucketId cannot be empty');\n    }\n  }\n\n  /**\n   * Ensure authentication before making requests\n   * @throws {Error} If not authenticated\n   */\n  ensureAuthenticated() {\n    if (!this.authManager.isAuthenticated()) {\n      throw new Error('Not authenticated. Call authorize() first.');\n    }\n\n    // Update endpoint builder with current auth context\n    this.endpointBuilder.setAuthContext(this.authManager.getAuthContext());\n  }\n\n  /**\n   * Create a new bucket\n   * @param {Object|string} options - Bucket creation options or bucket name (for backward compatibility)\n   * @param {string} options.bucketName - Name of the bucket to create\n   * @param {string} options.bucketType - Type of bucket (allPublic or allPrivate)\n   * @param {string} [bucketType] - Bucket type (for backward compatibility when first param is string)\n   * @returns {Promise<Object>} Bucket creation response\n   */\n  async create(options, bucketType) {\n    this.ensureAuthenticated();\n\n    // Handle backward compatibility: create(bucketName, bucketType)\n    let bucketName, type;\n    if (typeof options === 'string') {\n      bucketName = options;\n      type = bucketType;\n    } else if (options && typeof options === 'object') {\n      bucketName = options.bucketName;\n      type = options.bucketType;\n    } else {\n      throw new Error(\n        'Invalid arguments. Expected object with bucketName and bucketType, or bucketName and bucketType as separate parameters'\n      );\n    }\n\n    // Validate inputs\n    this.validateBucketName(bucketName);\n    this.validateBucketType(type);\n\n    const requestData = {\n      accountId: this.authManager.getAccountId(),\n      bucketName: bucketName,\n      bucketType: type,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getCreateBucketUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 bucket creation errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.DUPLICATE_BUCKET_NAME) {\n          const b2Error = new Error(\n            `Bucket name '${bucketName}' already exists`\n          );\n          b2Error.code = B2_ERROR_CODES.DUPLICATE_BUCKET_NAME;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n        if (error.code === B2_ERROR_CODES.INVALID_BUCKET_NAME) {\n          const b2Error = new Error(`Invalid bucket name: ${bucketName}`);\n          b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_NAME;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a bucket\n   * @param {Object|string} options - Bucket deletion options or bucket ID (for backward compatibility)\n   * @param {string} options.bucketId - ID of the bucket to delete\n   * @returns {Promise<Object>} Bucket deletion response\n   */\n  async delete(options) {\n    this.ensureAuthenticated();\n\n    // Handle backward compatibility: delete(bucketId)\n    let bucketId;\n    if (typeof options === 'string') {\n      bucketId = options;\n    } else if (options && typeof options === 'object') {\n      bucketId = options.bucketId;\n    } else {\n      throw new Error(\n        'Invalid arguments. Expected object with bucketId or bucketId as string'\n      );\n    }\n\n    // Validate inputs\n    this.validateBucketId(bucketId);\n\n    const requestData = {\n      accountId: this.authManager.getAccountId(),\n      bucketId: bucketId,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getDeleteBucketUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 bucket deletion errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.INVALID_BUCKET_ID) {\n          const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n          b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n        if (error.code === B2_ERROR_CODES.BUCKET_NOT_EMPTY) {\n          const b2Error = new Error(\n            `Bucket is not empty and cannot be deleted`\n          );\n          b2Error.code = B2_ERROR_CODES.BUCKET_NOT_EMPTY;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * List buckets\n   * @param {Object} [options={}] - List options\n   * @returns {Promise<Object>} List of buckets response\n   */\n  async list(options = {}) {\n    this.ensureAuthenticated();\n\n    const requestData = {\n      accountId: this.authManager.getAccountId(),\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getListBucketsUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Get bucket information by name or ID\n   * @param {Object} options - Get bucket options\n   * @param {string} [options.bucketName] - Name of the bucket to get\n   * @param {string} [options.bucketId] - ID of the bucket to get\n   * @returns {Promise<Object>} Bucket information response\n   */\n  async get(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    if (!options.bucketName && !options.bucketId) {\n      throw new Error('Either bucketName or bucketId is required');\n    }\n\n    if (options.bucketName && options.bucketId) {\n      throw new Error('Cannot specify both bucketName and bucketId');\n    }\n\n    const requestData = {\n      accountId: this.authManager.getAccountId(),\n    };\n\n    // Add either bucketName or bucketId to the request\n    if (options.bucketName) {\n      this.validateBucketName(options.bucketName);\n      requestData.bucketName = options.bucketName;\n    } else {\n      this.validateBucketId(options.bucketId);\n      requestData.bucketId = options.bucketId;\n    }\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getListBucketsUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Update bucket type\n   * @param {Object|string} options - Bucket update options or bucket ID (for backward compatibility)\n   * @param {string} options.bucketId - ID of the bucket to update\n   * @param {string} options.bucketType - New bucket type\n   * @param {string} [bucketType] - New bucket type (for backward compatibility when first param is string)\n   * @returns {Promise<Object>} Bucket update response\n   */\n  async update(options, bucketType) {\n    this.ensureAuthenticated();\n\n    // Handle backward compatibility: update(bucketId, bucketType)\n    let bucketId, type;\n    if (typeof options === 'string') {\n      bucketId = options;\n      type = bucketType;\n    } else if (options && typeof options === 'object') {\n      bucketId = options.bucketId;\n      type = options.bucketType;\n    } else {\n      throw new Error(\n        'Invalid arguments. Expected object with bucketId and bucketType, or bucketId and bucketType as separate parameters'\n      );\n    }\n\n    // Validate inputs\n    this.validateBucketId(bucketId);\n    this.validateBucketType(type);\n\n    const requestData = {\n      accountId: this.authManager.getAccountId(),\n      bucketId: bucketId,\n      bucketType: type,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getUpdateBucketUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 bucket update errors\n      if (\n        error.status === 400 &&\n        error.code === B2_ERROR_CODES.INVALID_BUCKET_ID\n      ) {\n        const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n        b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n        b2Error.status = 400;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get upload URL for a bucket\n   * @param {Object|string} options - Upload URL options or bucket ID (for backward compatibility)\n   * @param {string} options.bucketId - ID of the bucket to get upload URL for\n   * @returns {Promise<Object>} Upload URL response\n   */\n  async getUploadUrl(options) {\n    this.ensureAuthenticated();\n\n    // Handle backward compatibility: getUploadUrl(bucketId)\n    let bucketId;\n    if (typeof options === 'string') {\n      bucketId = options;\n    } else if (options && typeof options === 'object') {\n      bucketId = options.bucketId;\n    } else {\n      throw new Error(\n        'Invalid arguments. Expected object with bucketId or bucketId as string'\n      );\n    }\n\n    // Validate inputs\n    this.validateBucketId(bucketId);\n\n    const requestData = {\n      bucketId: bucketId,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getUploadUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 upload URL errors\n      if (\n        error.status === 400 &&\n        error.code === B2_ERROR_CODES.INVALID_BUCKET_ID\n      ) {\n        const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n        b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n        b2Error.status = 400;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n}\n\n// Export bucket types for convenience\nexport { BUCKET_TYPES };\n\nexport default BucketManager;\n","/**\n * Cryptographic utilities for B2 API operations\n * Uses Node.js crypto module and Web Crypto API for browser compatibility\n */\n\n// Check if we're in Node.js or browser environment\nconst isNode =\n  typeof process !== 'undefined' && process.versions && process.versions.node;\n\n// Lazy-load crypto module to avoid top-level await\nlet crypto;\nlet cryptoPromise;\n\nfunction getCrypto() {\n  if (crypto) {\n    return crypto;\n  }\n\n  if (isNode) {\n    // Node.js environment - use dynamic import\n    if (!cryptoPromise) {\n      cryptoPromise = import('crypto').then((cryptoModule) => {\n        crypto = cryptoModule;\n        return crypto;\n      });\n    }\n    return cryptoPromise;\n  } else {\n    // Browser environment - use Web Crypto API\n    crypto = globalThis.crypto;\n    return crypto;\n  }\n}\n\n/**\n * SHA1 hashing utilities for file integrity verification\n */\nexport class Sha1Hasher {\n  /**\n   * Calculate SHA1 hash of data\n   * @param {Buffer|Uint8Array|string} data - Data to hash\n   * @returns {Promise<string>} SHA1 hash as hex string\n   */\n  static async hash(data) {\n    if (isNode) {\n      return this.hashNode(data);\n    } else {\n      return this.hashBrowser(data);\n    }\n  }\n\n  /**\n   * Calculate SHA1 hash using Node.js crypto module\n   * @param {Buffer|string} data - Data to hash\n   * @returns {Promise<string>} SHA1 hash as hex string\n   */\n  static async hashNode(data) {\n    const cryptoModule = await getCrypto();\n    const hash = cryptoModule.createHash('sha1');\n    hash.update(data);\n    return hash.digest('hex');\n  }\n\n  /**\n   * Calculate SHA1 hash using Web Crypto API\n   * @param {Uint8Array|string} data - Data to hash\n   * @returns {Promise<string>} SHA1 hash as hex string\n   */\n  static async hashBrowser(data) {\n    // Convert string to Uint8Array if needed\n    if (typeof data === 'string') {\n      data = new TextEncoder().encode(data);\n    }\n\n    // Calculate hash using Web Crypto API\n    const hashBuffer = await crypto.subtle.digest('SHA-1', data);\n\n    // Convert to hex string\n    const hashArray = new Uint8Array(hashBuffer);\n    return Array.from(hashArray)\n      .map((byte) => byte.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  /**\n   * Create a streaming SHA1 hasher for large files\n   * @returns {Sha1Stream} Streaming hasher instance\n   */\n  static createStream() {\n    return new Sha1Stream();\n  }\n\n  /**\n   * Verify SHA1 hash matches expected value\n   * @param {Buffer|Uint8Array|string} data - Data to verify\n   * @param {string} expectedHash - Expected SHA1 hash\n   * @returns {Promise<boolean>} True if hash matches\n   */\n  static async verify(data, expectedHash) {\n    const actualHash = await this.hash(data);\n    return actualHash.toLowerCase() === expectedHash.toLowerCase();\n  }\n\n  /**\n   * Calculate SHA1 hash of a file (Node.js only)\n   * @param {string} filePath - Path to file\n   * @returns {Promise<string>} SHA1 hash as hex string\n   */\n  static async hashFile(filePath) {\n    if (!isNode) {\n      throw new Error('File hashing is only available in Node.js environment');\n    }\n\n    const fs = await import('fs');\n    const stream = fs.createReadStream(filePath);\n    const hasher = this.createStream();\n\n    return new Promise((resolve, reject) => {\n      stream.on('data', (chunk) => hasher.update(chunk));\n      stream.on('end', () => resolve(hasher.digest()));\n      stream.on('error', reject);\n    });\n  }\n}\n\n/**\n * Streaming SHA1 hasher for processing large amounts of data\n */\nexport class Sha1Stream {\n  constructor() {\n    this.isNode = isNode;\n    if (isNode) {\n      this.cryptoPromise = getCrypto();\n      this.hash = null;\n    } else {\n      this.chunks = [];\n    }\n  }\n\n  /**\n   * Initialize the hasher (async for Node.js)\n   * @returns {Promise<void>}\n   */\n  async init() {\n    if (this.isNode && !this.hash) {\n      const cryptoModule = await this.cryptoPromise;\n      this.hash = cryptoModule.createHash('sha1');\n    }\n  }\n\n  /**\n   * Update hash with new data\n   * @param {Buffer|Uint8Array|string} data - Data to add to hash\n   */\n  async update(data) {\n    if (this.isNode) {\n      await this.init();\n      this.hash.update(data);\n    } else {\n      // Store chunks for browser processing\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      this.chunks.push(data);\n    }\n  }\n\n  /**\n   * Finalize hash and return result\n   * @returns {Promise<string>} SHA1 hash as hex string\n   */\n  async digest() {\n    if (this.isNode) {\n      await this.init();\n      return this.hash.digest('hex');\n    } else {\n      // Combine all chunks and hash in browser\n      const totalLength = this.chunks.reduce(\n        (sum, chunk) => sum + chunk.length,\n        0\n      );\n      const combined = new Uint8Array(totalLength);\n      let offset = 0;\n\n      for (const chunk of this.chunks) {\n        combined.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      return Sha1Hasher.hashBrowser(combined);\n    }\n  }\n}\n\n/**\n * Utility functions for working with hashes and checksums\n */\nexport const HashUtils = {\n  /**\n   * Validate SHA1 hash format\n   * @param {string} hash - Hash to validate\n   * @returns {boolean} True if valid SHA1 format\n   */\n  isValidSha1(hash) {\n    return typeof hash === 'string' && /^[a-fA-F0-9]{40}$/.test(hash);\n  },\n\n  /**\n   * Normalize SHA1 hash to lowercase\n   * @param {string} hash - Hash to normalize\n   * @returns {string} Normalized hash\n   */\n  normalizeSha1(hash) {\n    if (!this.isValidSha1(hash)) {\n      throw new Error('Invalid SHA1 hash format');\n    }\n    return hash.toLowerCase();\n  },\n\n  /**\n   * Compare two SHA1 hashes for equality\n   * @param {string} hash1 - First hash\n   * @param {string} hash2 - Second hash\n   * @returns {boolean} True if hashes are equal\n   */\n  compareSha1(hash1, hash2) {\n    if (!this.isValidSha1(hash1) || !this.isValidSha1(hash2)) {\n      return false;\n    }\n    return hash1.toLowerCase() === hash2.toLowerCase();\n  },\n\n  /**\n   * Generate a random SHA1-like string for testing\n   * @returns {string} Random 40-character hex string\n   */\n  generateRandomSha1() {\n    const chars = '0123456789abcdef';\n    let result = '';\n    for (let i = 0; i < 40; i++) {\n      result += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return result;\n  },\n};\n\n/**\n * Progress tracking utilities for hash calculation\n */\nexport class ProgressiveHasher {\n  constructor(onProgress) {\n    this.hasher = new Sha1Stream();\n    this.onProgress = onProgress;\n    this.totalBytes = 0;\n    this.processedBytes = 0;\n  }\n\n  /**\n   * Set the total size for progress calculation\n   * @param {number} totalSize - Total size in bytes\n   */\n  setTotalSize(totalSize) {\n    this.totalBytes = totalSize;\n  }\n\n  /**\n   * Update hash with data and report progress\n   * @param {Buffer|Uint8Array|string} data - Data to hash\n   */\n  async update(data) {\n    await this.hasher.update(data);\n\n    if (typeof data === 'string') {\n      this.processedBytes += new TextEncoder().encode(data).length;\n    } else {\n      this.processedBytes += data.length;\n    }\n\n    if (this.onProgress && this.totalBytes > 0) {\n      const progress = Math.min(this.processedBytes / this.totalBytes, 1);\n      this.onProgress({\n        loaded: this.processedBytes,\n        total: this.totalBytes,\n        progress: progress,\n      });\n    }\n  }\n\n  /**\n   * Finalize hash calculation\n   * @returns {Promise<string>} SHA1 hash as hex string\n   */\n  async digest() {\n    return await this.hasher.digest();\n  }\n}\n\n// Export convenience functions\nexport const sha1 = Sha1Hasher.hash.bind(Sha1Hasher);\nexport const verifySha1 = Sha1Hasher.verify.bind(Sha1Hasher);\nexport const createSha1Stream = Sha1Hasher.createStream.bind(Sha1Hasher);\n","/**\n * File Manager for B2 API\n * Handles file upload, download, listing, and management operations\n */\n\nimport { B2_ERROR_CODES, CONTENT_TYPES, DEFAULT_CONFIG } from '../constants.js';\nimport { Validator } from '../utils/validation.js';\nimport { EndpointBuilder } from '../utils/endpoints.js';\nimport { HeaderUtils } from '../utils/headers.js';\nimport { Sha1Hasher } from '../utils/crypto.js';\n\nexport class FileManager {\n  constructor(httpClient, authManager, config = {}) {\n    this.httpClient = httpClient;\n    this.authManager = authManager;\n    this.config = config;\n    this.endpointBuilder = new EndpointBuilder();\n  }\n\n  /**\n   * Ensure authentication before making requests\n   * @throws {Error} If not authenticated\n   */\n  ensureAuthenticated() {\n    if (!this.authManager.isAuthenticated()) {\n      throw new Error('Not authenticated. Call authorize() first.');\n    }\n\n    // Update endpoint builder with current auth context\n    this.endpointBuilder.setAuthContext(this.authManager.getAuthContext());\n  }\n\n  /**\n   * Validate file name according to B2 requirements\n   * @param {string} fileName - File name to validate\n   * @throws {Error} If file name is invalid\n   */\n  validateFileName(fileName) {\n    if (typeof fileName !== 'string') {\n      throw new Error('fileName is required and must be a string');\n    }\n\n    if (fileName.length === 0) {\n      throw new Error('File name cannot be empty');\n    }\n\n    if (fileName.length > 1024) {\n      throw new Error('File name cannot exceed 1024 characters');\n    }\n\n    // B2 doesn't allow certain characters in file names\n    const invalidChars = /[\\x00-\\x1f\\x7f]/;\n    if (invalidChars.test(fileName)) {\n      throw new Error('File name contains invalid characters');\n    }\n  }\n\n  /**\n   * Validate file ID\n   * @param {string} fileId - File ID to validate\n   * @throws {Error} If file ID is invalid\n   */\n  validateFileId(fileId) {\n    if (typeof fileId !== 'string') {\n      throw new Error('fileId is required and must be a string');\n    }\n\n    if (fileId.trim().length === 0) {\n      throw new Error('fileId cannot be empty');\n    }\n  }\n\n  /**\n   * Upload a file to B2\n   * @param {Object} options - Upload options\n   * @param {string} options.uploadUrl - Upload URL from getUploadUrl\n   * @param {string} options.uploadAuthToken - Upload authorization token\n   * @param {string} options.fileName - Name of the file\n   * @param {Buffer|Uint8Array|string} options.data - File data to upload\n   * @param {string} [options.contentType] - Content type (defaults to application/octet-stream)\n   * @param {string} [options.contentSha1] - SHA1 hash of content (will be calculated if not provided)\n   * @param {Object} [options.info] - File info metadata\n   * @param {Function} [options.onUploadProgress] - Progress callback function\n   * @returns {Promise<Object>} Upload response\n   */\n  async uploadFile(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const {\n      uploadUrl,\n      uploadAuthToken,\n      fileName,\n      data,\n      contentType = CONTENT_TYPES.OCTET_STREAM,\n      contentSha1,\n      info,\n      onUploadProgress,\n    } = options;\n\n    // Validate required parameters\n    if (!uploadUrl || typeof uploadUrl !== 'string') {\n      throw new Error('uploadUrl is required and must be a string');\n    }\n\n    if (!uploadAuthToken || typeof uploadAuthToken !== 'string') {\n      throw new Error('uploadAuthToken is required and must be a string');\n    }\n\n    this.validateFileName(fileName);\n\n    if (!data) {\n      throw new Error('data is required');\n    }\n\n    // Calculate content length\n    let contentLength;\n    if (typeof data === 'string') {\n      contentLength = new TextEncoder().encode(data).length;\n    } else {\n      contentLength = data.length;\n    }\n\n    // Calculate SHA1 if not provided\n    let sha1Hash = contentSha1;\n    if (!sha1Hash) {\n      sha1Hash = await Sha1Hasher.hash(data);\n    }\n\n    // Create upload headers\n    const headers = HeaderUtils.createUploadHeaders({\n      authToken: uploadAuthToken,\n      fileName,\n      contentType,\n      contentSha1: sha1Hash,\n      contentLength,\n      info,\n    });\n\n    try {\n      const response = await this.httpClient.post(uploadUrl, data, {\n        headers,\n        timeout: this.config.uploadTimeout || this.config.timeout,\n        onUploadProgress,\n      });\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 upload errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.FILE_NOT_PRESENT) {\n          const b2Error = new Error(`File upload failed: ${error.message}`);\n          b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get file information\n   * @param {Object|string} options - File info options or file ID (for backward compatibility)\n   * @param {string} options.fileId - ID of the file to get info for\n   * @returns {Promise<Object>} File information response\n   */\n  async getFileInfo(options) {\n    this.ensureAuthenticated();\n\n    // Handle backward compatibility: getFileInfo(fileId)\n    let fileId;\n    if (typeof options === 'string') {\n      fileId = options;\n    } else if (options && typeof options === 'object') {\n      fileId = options.fileId;\n    } else {\n      throw new Error(\n        'Invalid arguments. Expected object with fileId or fileId as string'\n      );\n    }\n\n    // Validate inputs\n    this.validateFileId(fileId);\n\n    const requestData = {\n      fileId: fileId,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getFileInfoUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 file info errors\n      if (\n        error.status === 400 &&\n        error.code === B2_ERROR_CODES.FILE_NOT_PRESENT\n      ) {\n        const b2Error = new Error(`File not found: ${fileId}`);\n        b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n        b2Error.status = 400;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a file version\n   * @param {Object} options - Delete options\n   * @param {string} options.fileId - ID of the file to delete\n   * @param {string} options.fileName - Name of the file to delete\n   * @returns {Promise<Object>} Delete response\n   */\n  async deleteFileVersion(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const { fileId, fileName } = options;\n\n    // Validate inputs\n    this.validateFileId(fileId);\n    this.validateFileName(fileName);\n\n    const requestData = {\n      fileId: fileId,\n      fileName: fileName,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getDeleteFileVersionUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 delete errors\n      if (\n        error.status === 400 &&\n        error.code === B2_ERROR_CODES.FILE_NOT_PRESENT\n      ) {\n        const b2Error = new Error(`File not found: ${fileId}`);\n        b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n        b2Error.status = 400;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * List file names in a bucket\n   * @param {Object} options - List options\n   * @param {string} options.bucketId - ID of the bucket to list files from\n   * @param {string} [options.startFileName] - File name to start listing from\n   * @param {number} [options.maxFileCount] - Maximum number of files to return (default: 100, max: 10000)\n   * @param {string} [options.prefix] - Only return file names that start with this prefix\n   * @param {string} [options.delimiter] - Delimiter for grouping file names\n   * @returns {Promise<Object>} List of file names response\n   */\n  async listFileNames(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const { bucketId, startFileName, maxFileCount, prefix, delimiter } =\n      options;\n\n    // Validate required parameters\n    if (typeof bucketId !== 'string') {\n      throw new Error('bucketId is required and must be a string');\n    }\n\n    if (bucketId.trim().length === 0) {\n      throw new Error('bucketId cannot be empty');\n    }\n\n    // Validate optional parameters\n    if (maxFileCount !== undefined) {\n      if (\n        typeof maxFileCount !== 'number' ||\n        maxFileCount < 1 ||\n        maxFileCount > 10000\n      ) {\n        throw new Error('maxFileCount must be a number between 1 and 10000');\n      }\n    }\n\n    if (startFileName !== undefined && typeof startFileName !== 'string') {\n      throw new Error('startFileName must be a string');\n    }\n\n    if (prefix !== undefined && typeof prefix !== 'string') {\n      throw new Error('prefix must be a string');\n    }\n\n    if (delimiter !== undefined && typeof delimiter !== 'string') {\n      throw new Error('delimiter must be a string');\n    }\n\n    const requestData = {\n      bucketId: bucketId,\n    };\n\n    // Add optional parameters\n    if (startFileName !== undefined) {\n      requestData.startFileName = startFileName;\n    }\n    if (maxFileCount !== undefined) {\n      requestData.maxFileCount = maxFileCount;\n    }\n    if (prefix !== undefined) {\n      requestData.prefix = prefix;\n    }\n    if (delimiter !== undefined) {\n      requestData.delimiter = delimiter;\n    }\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getListFileNamesUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 list errors\n      if (\n        error.status === 400 &&\n        error.code === B2_ERROR_CODES.INVALID_BUCKET_ID\n      ) {\n        const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n        b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n        b2Error.status = 400;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * List file versions in a bucket\n   * @param {Object} options - List options\n   * @param {string} options.bucketId - ID of the bucket to list file versions from\n   * @param {string} [options.startFileName] - File name to start listing from\n   * @param {string} [options.startFileId] - File ID to start listing from\n   * @param {number} [options.maxFileCount] - Maximum number of file versions to return (default: 100, max: 10000)\n   * @param {string} [options.prefix] - Only return file names that start with this prefix\n   * @param {string} [options.delimiter] - Delimiter for grouping file names\n   * @returns {Promise<Object>} List of file versions response\n   */\n  async listFileVersions(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const {\n      bucketId,\n      startFileName,\n      startFileId,\n      maxFileCount,\n      prefix,\n      delimiter,\n    } = options;\n\n    // Validate required parameters\n    if (typeof bucketId !== 'string') {\n      throw new Error('bucketId is required and must be a string');\n    }\n\n    if (bucketId.trim().length === 0) {\n      throw new Error('bucketId cannot be empty');\n    }\n\n    // Validate optional parameters\n    if (maxFileCount !== undefined) {\n      if (\n        typeof maxFileCount !== 'number' ||\n        maxFileCount < 1 ||\n        maxFileCount > 10000\n      ) {\n        throw new Error('maxFileCount must be a number between 1 and 10000');\n      }\n    }\n\n    if (startFileName !== undefined && typeof startFileName !== 'string') {\n      throw new Error('startFileName must be a string');\n    }\n\n    if (startFileId !== undefined && typeof startFileId !== 'string') {\n      throw new Error('startFileId must be a string');\n    }\n\n    if (prefix !== undefined && typeof prefix !== 'string') {\n      throw new Error('prefix must be a string');\n    }\n\n    if (delimiter !== undefined && typeof delimiter !== 'string') {\n      throw new Error('delimiter must be a string');\n    }\n\n    const requestData = {\n      bucketId: bucketId,\n    };\n\n    // Add optional parameters\n    if (startFileName !== undefined) {\n      requestData.startFileName = startFileName;\n    }\n    if (startFileId !== undefined) {\n      requestData.startFileId = startFileId;\n    }\n    if (maxFileCount !== undefined) {\n      requestData.maxFileCount = maxFileCount;\n    }\n    if (prefix !== undefined) {\n      requestData.prefix = prefix;\n    }\n    if (delimiter !== undefined) {\n      requestData.delimiter = delimiter;\n    }\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getListFileVersionsUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 list errors\n      if (\n        error.status === 400 &&\n        error.code === B2_ERROR_CODES.INVALID_BUCKET_ID\n      ) {\n        const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n        b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n        b2Error.status = 400;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Hide a file (make it invisible in file listings)\n   * @param {Object} options - Hide file options\n   * @param {string} options.bucketId - ID of the bucket containing the file\n   * @param {string} options.fileName - Name of the file to hide\n   * @returns {Promise<Object>} Hide file response\n   */\n  async hideFile(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const { bucketId, fileName } = options;\n\n    // Validate required parameters\n    if (typeof bucketId !== 'string') {\n      throw new Error('bucketId is required and must be a string');\n    }\n\n    if (bucketId.trim().length === 0) {\n      throw new Error('bucketId cannot be empty');\n    }\n\n    this.validateFileName(fileName);\n\n    const requestData = {\n      bucketId: bucketId,\n      fileName: fileName,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getHideFileUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 hide file errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.INVALID_BUCKET_ID) {\n          const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n          b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n        if (error.code === B2_ERROR_CODES.FILE_NOT_PRESENT) {\n          const b2Error = new Error(`File not found: ${fileName}`);\n          b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Download a file by name\n   * @param {Object|string} options - Download options or bucket name (for backward compatibility)\n   * @param {string} options.bucketName - Name of the bucket containing the file\n   * @param {string} options.fileName - Name of the file to download\n   * @param {string} [options.responseType] - Response type: 'json', 'text', 'arraybuffer', 'blob', 'stream' (default: 'arraybuffer')\n   * @param {Function} [options.onDownloadProgress] - Progress callback function\n   * @param {Object} [options.headers] - Additional headers for the request\n   * @param {string} [fileName] - File name (for backward compatibility when first param is bucket name)\n   * @returns {Promise<Object>} Download response with file data\n   */\n  async downloadFileByName(options, fileName) {\n    this.ensureAuthenticated();\n\n    // Handle backward compatibility: downloadFileByName(bucketName, fileName)\n    let bucketName, actualFileName, responseType, onDownloadProgress, headers;\n\n    if (typeof options === 'string') {\n      // Legacy format: downloadFileByName(bucketName, fileName)\n      bucketName = options;\n      actualFileName = fileName;\n      responseType = 'arraybuffer';\n      onDownloadProgress = undefined;\n      headers = {};\n    } else if (options && typeof options === 'object') {\n      // New format: downloadFileByName({ bucketName, fileName, ... })\n      bucketName = options.bucketName;\n      actualFileName = options.fileName;\n      responseType = options.responseType || 'arraybuffer';\n      onDownloadProgress = options.onDownloadProgress;\n      headers = options.headers || {};\n    } else {\n      throw new Error(\n        'Invalid arguments. Expected object with bucketName and fileName, or bucketName and fileName as separate strings'\n      );\n    }\n\n    // Validate required parameters\n    if (typeof bucketName !== 'string') {\n      throw new Error('bucketName is required and must be a string');\n    }\n\n    if (bucketName.trim().length === 0) {\n      throw new Error('bucketName cannot be empty');\n    }\n\n    this.validateFileName(actualFileName);\n\n    // Validate response type\n    const validResponseTypes = [\n      'json',\n      'text',\n      'arraybuffer',\n      'blob',\n      'stream',\n    ];\n    if (!validResponseTypes.includes(responseType)) {\n      throw new Error(\n        `Invalid responseType. Must be one of: ${validResponseTypes.join(', ')}`\n      );\n    }\n\n    try {\n      const downloadUrl = this.endpointBuilder.getDownloadFileByNameUrl(\n        bucketName,\n        actualFileName\n      );\n\n      const response = await this.httpClient.get(downloadUrl, {\n        headers: {\n          ...this.authManager.getAuthHeaders(),\n          ...headers,\n        },\n        responseType,\n        onDownloadProgress,\n        timeout: this.config.downloadTimeout || this.config.timeout,\n      });\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 download errors\n      if (error.status === 404) {\n        const b2Error = new Error(\n          `File not found: ${actualFileName} in bucket ${bucketName}`\n        );\n        b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n        b2Error.status = 404;\n        throw b2Error;\n      }\n\n      if (error.status === 401) {\n        const b2Error = new Error(\n          `Unauthorized access to file: ${actualFileName}`\n        );\n        b2Error.code = B2_ERROR_CODES.BAD_AUTH_TOKEN;\n        b2Error.status = 401;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Download a file by ID\n   * @param {Object|string} options - Download options or file ID (for backward compatibility)\n   * @param {string} options.fileId - ID of the file to download\n   * @param {string} [options.responseType] - Response type: 'json', 'text', 'arraybuffer', 'blob', 'stream' (default: 'arraybuffer')\n   * @param {Function} [options.onDownloadProgress] - Progress callback function\n   * @param {Object} [options.headers] - Additional headers for the request\n   * @returns {Promise<Object>} Download response with file data\n   */\n  async downloadFileById(options) {\n    this.ensureAuthenticated();\n\n    // Handle backward compatibility: downloadFileById(fileId)\n    let fileId, responseType, onDownloadProgress, headers;\n\n    if (typeof options === 'string') {\n      // Legacy format: downloadFileById(fileId)\n      fileId = options;\n      responseType = 'arraybuffer';\n      onDownloadProgress = undefined;\n      headers = {};\n    } else if (options && typeof options === 'object') {\n      // New format: downloadFileById({ fileId, ... })\n      fileId = options.fileId;\n      responseType = options.responseType || 'arraybuffer';\n      onDownloadProgress = options.onDownloadProgress;\n      headers = options.headers || {};\n    } else {\n      throw new Error(\n        'Invalid arguments. Expected object with fileId or fileId as string'\n      );\n    }\n\n    // Validate required parameters\n    this.validateFileId(fileId);\n\n    // Validate response type\n    const validResponseTypes = [\n      'json',\n      'text',\n      'arraybuffer',\n      'blob',\n      'stream',\n    ];\n    if (!validResponseTypes.includes(responseType)) {\n      throw new Error(\n        `Invalid responseType. Must be one of: ${validResponseTypes.join(', ')}`\n      );\n    }\n\n    try {\n      const downloadUrl = this.endpointBuilder.getDownloadFileByIdUrl(fileId);\n\n      const response = await this.httpClient.get(downloadUrl, {\n        headers: {\n          ...this.authManager.getAuthHeaders(),\n          ...headers,\n        },\n        responseType,\n        onDownloadProgress,\n        timeout: this.config.downloadTimeout || this.config.timeout,\n      });\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 download errors\n      if (error.status === 404) {\n        const b2Error = new Error(`File not found: ${fileId}`);\n        b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n        b2Error.status = 404;\n        throw b2Error;\n      }\n\n      if (error.status === 401) {\n        const b2Error = new Error(`Unauthorized access to file: ${fileId}`);\n        b2Error.code = B2_ERROR_CODES.BAD_AUTH_TOKEN;\n        b2Error.status = 401;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get download authorization for private files\n   * @param {Object} options - Download authorization options\n   * @param {string} options.bucketId - ID of the bucket containing the files\n   * @param {string} options.fileNamePrefix - Prefix of file names to authorize (can be empty string for all files)\n   * @param {number} [options.validDurationInSeconds] - How long the authorization is valid (default: 604800 = 7 days, max: 604800)\n   * @param {string} [options.b2ContentDisposition] - Content-Disposition header value for downloads\n   * @returns {Promise<Object>} Download authorization response\n   */\n  async getDownloadAuthorization(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const {\n      bucketId,\n      fileNamePrefix,\n      validDurationInSeconds = 604800, // 7 days default\n      b2ContentDisposition,\n    } = options;\n\n    // Validate required parameters\n    if (typeof bucketId !== 'string') {\n      throw new Error('bucketId is required and must be a string');\n    }\n\n    if (bucketId.trim().length === 0) {\n      throw new Error('bucketId cannot be empty');\n    }\n\n    if (typeof fileNamePrefix !== 'string') {\n      throw new Error(\n        'fileNamePrefix is required and must be a string (can be empty)'\n      );\n    }\n\n    // Validate optional parameters\n    if (validDurationInSeconds !== undefined) {\n      if (\n        typeof validDurationInSeconds !== 'number' ||\n        validDurationInSeconds < 1 ||\n        validDurationInSeconds > 604800\n      ) {\n        throw new Error(\n          'validDurationInSeconds must be a number between 1 and 604800 (7 days)'\n        );\n      }\n    }\n\n    if (\n      b2ContentDisposition !== undefined &&\n      typeof b2ContentDisposition !== 'string'\n    ) {\n      throw new Error('b2ContentDisposition must be a string');\n    }\n\n    const requestData = {\n      bucketId: bucketId,\n      fileNamePrefix: fileNamePrefix,\n      validDurationInSeconds: validDurationInSeconds,\n    };\n\n    // Add optional parameters\n    if (b2ContentDisposition !== undefined) {\n      requestData.b2ContentDisposition = b2ContentDisposition;\n    }\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getDownloadAuthorizationUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 download authorization errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.INVALID_BUCKET_ID) {\n          const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n          b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n        if (error.code === B2_ERROR_CODES.NOT_ALLOWED) {\n          const b2Error = new Error(\n            `Not allowed to get download authorization for bucket: ${bucketId}`\n          );\n          b2Error.code = B2_ERROR_CODES.NOT_ALLOWED;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      if (error.status === 401) {\n        const b2Error = new Error(\n          `Unauthorized: Invalid credentials for download authorization`\n        );\n        b2Error.code = B2_ERROR_CODES.BAD_AUTH_TOKEN;\n        b2Error.status = 401;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  // ===== LARGE FILE OPERATIONS =====\n\n  /**\n   * Start a large file upload\n   * @param {Object} options - Start large file options\n   * @param {string} options.bucketId - ID of the bucket to upload to\n   * @param {string} options.fileName - Name of the file to upload\n   * @param {string} [options.contentType] - Content type (defaults to application/octet-stream)\n   * @param {Object} [options.fileInfo] - File info metadata\n   * @returns {Promise<Object>} Start large file response containing fileId\n   */\n  async startLargeFile(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const {\n      bucketId,\n      fileName,\n      contentType = CONTENT_TYPES.OCTET_STREAM,\n      fileInfo,\n    } = options;\n\n    // Validate required parameters\n    if (typeof bucketId !== 'string') {\n      throw new Error('bucketId is required and must be a string');\n    }\n\n    if (bucketId.trim().length === 0) {\n      throw new Error('bucketId cannot be empty');\n    }\n\n    this.validateFileName(fileName);\n\n    // Validate optional parameters\n    if (contentType !== undefined && typeof contentType !== 'string') {\n      throw new Error('contentType must be a string');\n    }\n\n    if (\n      fileInfo !== undefined &&\n      (typeof fileInfo !== 'object' || fileInfo === null)\n    ) {\n      throw new Error('fileInfo must be an object');\n    }\n\n    const requestData = {\n      bucketId: bucketId,\n      fileName: fileName,\n      contentType: contentType,\n    };\n\n    // Add file info if provided\n    if (fileInfo) {\n      requestData.fileInfo = fileInfo;\n    }\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getStartLargeFileUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 start large file errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.INVALID_BUCKET_ID) {\n          const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n          b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n        if (error.code === B2_ERROR_CODES.NOT_ALLOWED) {\n          const b2Error = new Error(\n            `Not allowed to upload to bucket: ${bucketId}`\n          );\n          b2Error.code = B2_ERROR_CODES.NOT_ALLOWED;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      if (error.status === 401) {\n        const b2Error = new Error(\n          `Unauthorized: Invalid credentials for large file upload`\n        );\n        b2Error.code = B2_ERROR_CODES.BAD_AUTH_TOKEN;\n        b2Error.status = 401;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get upload URL for a large file part\n   * @param {Object} options - Get upload part URL options\n   * @param {string} options.fileId - ID of the large file from startLargeFile\n   * @returns {Promise<Object>} Upload part URL response containing uploadUrl and authorizationToken\n   */\n  async getUploadPartUrl(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const { fileId } = options;\n\n    // Validate required parameters\n    this.validateFileId(fileId);\n\n    const requestData = {\n      fileId: fileId,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getUploadPartUrlEndpoint(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 get upload part URL errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.FILE_NOT_PRESENT) {\n          const b2Error = new Error(`Large file not found: ${fileId}`);\n          b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      if (error.status === 401) {\n        const b2Error = new Error(\n          `Unauthorized: Invalid credentials for upload part URL`\n        );\n        b2Error.code = B2_ERROR_CODES.BAD_AUTH_TOKEN;\n        b2Error.status = 401;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Upload a part of a large file\n   * @param {Object} options - Upload part options\n   * @param {string} options.uploadUrl - Upload URL from getUploadPartUrl\n   * @param {string} options.authorizationToken - Authorization token from getUploadPartUrl\n   * @param {number} options.partNumber - Part number (1-based, must be between 1 and 10000)\n   * @param {Buffer|Uint8Array|string} options.data - Part data to upload\n   * @param {string} [options.contentSha1] - SHA1 hash of part content (will be calculated if not provided)\n   * @param {Function} [options.onUploadProgress] - Progress callback function\n   * @returns {Promise<Object>} Upload part response\n   */\n  async uploadPart(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const {\n      uploadUrl,\n      authorizationToken,\n      partNumber,\n      data,\n      contentSha1,\n      onUploadProgress,\n    } = options;\n\n    // Validate required parameters\n    if (!uploadUrl || typeof uploadUrl !== 'string') {\n      throw new Error('uploadUrl is required and must be a string');\n    }\n\n    if (!authorizationToken || typeof authorizationToken !== 'string') {\n      throw new Error('authorizationToken is required and must be a string');\n    }\n\n    if (\n      typeof partNumber !== 'number' ||\n      partNumber < 1 ||\n      partNumber > 10000\n    ) {\n      throw new Error('partNumber must be a number between 1 and 10000');\n    }\n\n    if (!data) {\n      throw new Error('data is required');\n    }\n\n    // Calculate content length\n    let contentLength;\n    if (typeof data === 'string') {\n      contentLength = new TextEncoder().encode(data).length;\n    } else {\n      contentLength = data.length;\n    }\n\n    // Validate part size (minimum 5MB except for last part)\n    const MIN_PART_SIZE = 5 * 1024 * 1024; // 5MB\n    const MAX_PART_SIZE = 5 * 1024 * 1024 * 1024; // 5GB\n\n    if (contentLength > MAX_PART_SIZE) {\n      throw new Error(`Part size cannot exceed ${MAX_PART_SIZE} bytes (5GB)`);\n    }\n\n    // Calculate SHA1 if not provided\n    let sha1Hash = contentSha1;\n    if (!sha1Hash) {\n      sha1Hash = await Sha1Hasher.hash(data);\n    }\n\n    // Create upload headers for part\n    const headers = {\n      Authorization: authorizationToken,\n      'Content-Type': CONTENT_TYPES.OCTET_STREAM,\n      'Content-Length': contentLength.toString(),\n      'X-Bz-Content-Sha1': sha1Hash,\n      'X-Bz-Part-Number': partNumber.toString(),\n    };\n\n    try {\n      const response = await this.httpClient.post(uploadUrl, data, {\n        headers,\n        timeout: this.config.uploadTimeout || this.config.timeout,\n        onUploadProgress,\n      });\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 upload part errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.FILE_NOT_PRESENT) {\n          const b2Error = new Error(\n            `Large file upload failed: ${error.message}`\n          );\n          b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Finish a large file upload\n   * @param {Object} options - Finish large file options\n   * @param {string} options.fileId - ID of the large file from startLargeFile\n   * @param {Array<string>} options.partSha1Array - Array of SHA1 hashes for each part in order\n   * @returns {Promise<Object>} Finish large file response\n   */\n  async finishLargeFile(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const { fileId, partSha1Array } = options;\n\n    // Validate required parameters\n    this.validateFileId(fileId);\n\n    if (!Array.isArray(partSha1Array)) {\n      throw new Error('partSha1Array is required and must be an array');\n    }\n\n    if (partSha1Array.length === 0) {\n      throw new Error('partSha1Array cannot be empty');\n    }\n\n    if (partSha1Array.length > DEFAULT_CONFIG.MAX_PARTS_COUNT) {\n      throw new Error(\n        `partSha1Array cannot have more than ${DEFAULT_CONFIG.MAX_PARTS_COUNT} parts`\n      );\n    }\n\n    // Validate each SHA1 hash\n    partSha1Array.forEach((sha1, index) => {\n      if (typeof sha1 !== 'string') {\n        throw new Error(`partSha1Array[${index}] must be a string`);\n      }\n      if (sha1.length !== 40) {\n        throw new Error(\n          `partSha1Array[${index}] must be a 40-character SHA1 hash`\n        );\n      }\n      if (!/^[a-fA-F0-9]{40}$/.test(sha1)) {\n        throw new Error(\n          `partSha1Array[${index}] must be a valid hexadecimal SHA1 hash`\n        );\n      }\n    });\n\n    const requestData = {\n      fileId: fileId,\n      partSha1Array: partSha1Array,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getFinishLargeFileUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 finish large file errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.FILE_NOT_PRESENT) {\n          const b2Error = new Error(`Large file not found: ${fileId}`);\n          b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      if (error.status === 401) {\n        const b2Error = new Error(\n          `Unauthorized: Invalid credentials for finishing large file`\n        );\n        b2Error.code = B2_ERROR_CODES.BAD_AUTH_TOKEN;\n        b2Error.status = 401;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Cancel a large file upload\n   * @param {Object} options - Cancel large file options\n   * @param {string} options.fileId - ID of the large file from startLargeFile\n   * @returns {Promise<Object>} Cancel large file response\n   */\n  async cancelLargeFile(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const { fileId } = options;\n\n    // Validate required parameters\n    this.validateFileId(fileId);\n\n    const requestData = {\n      fileId: fileId,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getCancelLargeFileUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 cancel large file errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.FILE_NOT_PRESENT) {\n          const b2Error = new Error(`Large file not found: ${fileId}`);\n          b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      if (error.status === 401) {\n        const b2Error = new Error(\n          `Unauthorized: Invalid credentials for canceling large file`\n        );\n        b2Error.code = B2_ERROR_CODES.BAD_AUTH_TOKEN;\n        b2Error.status = 401;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * List parts of a large file upload\n   * @param {Object} options - List parts options\n   * @param {string} options.fileId - ID of the large file from startLargeFile\n   * @param {number} [options.startPartNumber] - Part number to start listing from (1-based)\n   * @param {number} [options.maxPartCount] - Maximum number of parts to return (default: 100, max: 10000)\n   * @returns {Promise<Object>} List parts response\n   */\n  async listParts(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const { fileId, startPartNumber, maxPartCount } = options;\n\n    // Validate required parameters\n    this.validateFileId(fileId);\n\n    // Validate optional parameters\n    if (startPartNumber !== undefined) {\n      if (\n        typeof startPartNumber !== 'number' ||\n        startPartNumber < 1 ||\n        startPartNumber > DEFAULT_CONFIG.MAX_PARTS_COUNT\n      ) {\n        throw new Error(\n          `startPartNumber must be a number between 1 and ${DEFAULT_CONFIG.MAX_PARTS_COUNT}`\n        );\n      }\n    }\n\n    if (maxPartCount !== undefined) {\n      if (\n        typeof maxPartCount !== 'number' ||\n        maxPartCount < 1 ||\n        maxPartCount > 10000\n      ) {\n        throw new Error('maxPartCount must be a number between 1 and 10000');\n      }\n    }\n\n    const requestData = {\n      fileId: fileId,\n    };\n\n    // Add optional parameters\n    if (startPartNumber !== undefined) {\n      requestData.startPartNumber = startPartNumber;\n    }\n    if (maxPartCount !== undefined) {\n      requestData.maxPartCount = maxPartCount;\n    }\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getListPartsUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 list parts errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.FILE_NOT_PRESENT) {\n          const b2Error = new Error(`Large file not found: ${fileId}`);\n          b2Error.code = B2_ERROR_CODES.FILE_NOT_PRESENT;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      if (error.status === 401) {\n        const b2Error = new Error(\n          `Unauthorized: Invalid credentials for listing parts`\n        );\n        b2Error.code = B2_ERROR_CODES.BAD_AUTH_TOKEN;\n        b2Error.status = 401;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * List unfinished large file uploads\n   * @param {Object} options - List unfinished large files options\n   * @param {string} options.bucketId - ID of the bucket to list unfinished files from\n   * @param {string} [options.startFileId] - File ID to start listing from\n   * @param {number} [options.maxFileCount] - Maximum number of files to return (default: 100, max: 10000)\n   * @returns {Promise<Object>} List unfinished large files response\n   */\n  async listUnfinishedLargeFiles(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const { bucketId, startFileId, maxFileCount } = options;\n\n    // Validate required parameters\n    if (typeof bucketId !== 'string') {\n      throw new Error('bucketId is required and must be a string');\n    }\n\n    if (bucketId.trim().length === 0) {\n      throw new Error('bucketId cannot be empty');\n    }\n\n    // Validate optional parameters\n    if (maxFileCount !== undefined) {\n      if (\n        typeof maxFileCount !== 'number' ||\n        maxFileCount < 1 ||\n        maxFileCount > 10000\n      ) {\n        throw new Error('maxFileCount must be a number between 1 and 10000');\n      }\n    }\n\n    if (startFileId !== undefined && typeof startFileId !== 'string') {\n      throw new Error('startFileId must be a string');\n    }\n\n    const requestData = {\n      bucketId: bucketId,\n    };\n\n    // Add optional parameters\n    if (startFileId !== undefined) {\n      requestData.startFileId = startFileId;\n    }\n    if (maxFileCount !== undefined) {\n      requestData.maxFileCount = maxFileCount;\n    }\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getListUnfinishedLargeFilesUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 list errors\n      if (\n        error.status === 400 &&\n        error.code === B2_ERROR_CODES.INVALID_BUCKET_ID\n      ) {\n        const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n        b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n        b2Error.status = 400;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n}\n\nexport default FileManager;\n","/**\n * Key Manager for B2 API\n * Handles application key CRUD operations\n */\n\nimport { KEY_CAPABILITIES, B2_ERROR_CODES } from '../constants.js';\nimport { Validator } from '../utils/validation.js';\nimport { EndpointBuilder } from '../utils/endpoints.js';\n\nexport class KeyManager {\n  constructor(httpClient, authManager, config = {}) {\n    this.httpClient = httpClient;\n    this.authManager = authManager;\n    this.config = config;\n    this.endpointBuilder = new EndpointBuilder();\n  }\n\n  /**\n   * Validate key name according to B2 requirements\n   * @param {string} keyName - Key name to validate\n   * @throws {Error} If key name is invalid\n   */\n  validateKeyName(keyName) {\n    if (\n      keyName === null ||\n      keyName === undefined ||\n      typeof keyName !== 'string'\n    ) {\n      throw new Error('keyName is required and must be a string');\n    }\n\n    if (keyName.length < 1 || keyName.length > 100) {\n      throw new Error('Key name must be between 1 and 100 characters');\n    }\n\n    // Key name can contain letters, numbers, and some special characters\n    const validPattern = /^[a-zA-Z0-9\\-_\\.]+$/;\n    if (!validPattern.test(keyName)) {\n      throw new Error(\n        'Key name can only contain letters, numbers, hyphens, underscores, and periods'\n      );\n    }\n  }\n\n  /**\n   * Validate key capabilities\n   * @param {Array<string>} capabilities - Array of capabilities to validate\n   * @throws {Error} If capabilities are invalid\n   */\n  validateCapabilities(capabilities) {\n    if (!Array.isArray(capabilities)) {\n      throw new Error('capabilities must be an array');\n    }\n\n    if (capabilities.length === 0) {\n      throw new Error('At least one capability is required');\n    }\n\n    const validCapabilities = Object.values(KEY_CAPABILITIES);\n    for (const capability of capabilities) {\n      if (typeof capability !== 'string') {\n        throw new Error('All capabilities must be strings');\n      }\n      if (!validCapabilities.includes(capability)) {\n        throw new Error(\n          `Invalid capability: ${capability}. Must be one of: ${validCapabilities.join(', ')}`\n        );\n      }\n    }\n\n    // Remove duplicates\n    const uniqueCapabilities = [...new Set(capabilities)];\n    if (uniqueCapabilities.length !== capabilities.length) {\n      throw new Error('Duplicate capabilities are not allowed');\n    }\n  }\n\n  /**\n   * Validate key ID\n   * @param {string} applicationKeyId - Key ID to validate\n   * @throws {Error} If key ID is invalid\n   */\n  validateKeyId(applicationKeyId) {\n    if (\n      applicationKeyId === null ||\n      applicationKeyId === undefined ||\n      typeof applicationKeyId !== 'string'\n    ) {\n      throw new Error('applicationKeyId is required and must be a string');\n    }\n\n    if (applicationKeyId.trim().length === 0) {\n      throw new Error('applicationKeyId cannot be empty');\n    }\n  }\n\n  /**\n   * Validate bucket ID (optional parameter for key restrictions)\n   * @param {string} bucketId - Bucket ID to validate\n   * @throws {Error} If bucket ID is invalid\n   */\n  validateBucketId(bucketId) {\n    if (bucketId !== null && bucketId !== undefined) {\n      if (typeof bucketId !== 'string') {\n        throw new Error('bucketId must be a string or null');\n      }\n      if (bucketId.trim().length === 0) {\n        throw new Error('bucketId cannot be empty string');\n      }\n    }\n  }\n\n  /**\n   * Validate name prefix (optional parameter for key restrictions)\n   * @param {string} namePrefix - Name prefix to validate\n   * @throws {Error} If name prefix is invalid\n   */\n  validateNamePrefix(namePrefix) {\n    if (namePrefix !== null && namePrefix !== undefined) {\n      if (typeof namePrefix !== 'string') {\n        throw new Error('namePrefix must be a string or null');\n      }\n      // Empty string is allowed for namePrefix\n    }\n  }\n\n  /**\n   * Ensure authentication before making requests\n   * @throws {Error} If not authenticated\n   */\n  ensureAuthenticated() {\n    if (!this.authManager.isAuthenticated()) {\n      throw new Error('Not authenticated. Call authorize() first.');\n    }\n\n    // Update endpoint builder with current auth context\n    this.endpointBuilder.setAuthContext(this.authManager.getAuthContext());\n  }\n\n  /**\n   * Create a new application key\n   * @param {Object} options - Key creation options\n   * @param {string} options.keyName - Name for the new key\n   * @param {Array<string>} options.capabilities - Array of capabilities for the key\n   * @param {string} [options.bucketId] - Optional bucket ID to restrict key to specific bucket\n   * @param {string} [options.namePrefix] - Optional name prefix to restrict key to files with specific prefix\n   * @param {number} [options.validDurationInSeconds] - Optional duration in seconds for key validity\n   * @returns {Promise<Object>} Key creation response\n   */\n  async createKey(options) {\n    this.ensureAuthenticated();\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('options object is required');\n    }\n\n    const {\n      keyName,\n      capabilities,\n      bucketId,\n      namePrefix,\n      validDurationInSeconds,\n    } = options;\n\n    // Validate required parameters\n    this.validateKeyName(keyName);\n    this.validateCapabilities(capabilities);\n\n    // Validate optional parameters\n    this.validateBucketId(bucketId);\n    this.validateNamePrefix(namePrefix);\n\n    if (validDurationInSeconds !== undefined) {\n      if (\n        typeof validDurationInSeconds !== 'number' ||\n        validDurationInSeconds <= 0\n      ) {\n        throw new Error('validDurationInSeconds must be a positive number');\n      }\n      if (validDurationInSeconds > 1000 * 24 * 60 * 60) {\n        // 1000 days in seconds\n        throw new Error('validDurationInSeconds cannot exceed 1000 days');\n      }\n    }\n\n    const requestData = {\n      accountId: this.authManager.getAccountId(),\n      keyName: keyName,\n      capabilities: capabilities,\n    };\n\n    // Add optional parameters if provided\n    if (bucketId) {\n      requestData.bucketId = bucketId;\n    }\n    if (namePrefix !== undefined) {\n      requestData.namePrefix = namePrefix;\n    }\n    if (validDurationInSeconds !== undefined) {\n      requestData.validDurationInSeconds = validDurationInSeconds;\n    }\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getCreateKeyUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 key creation errors\n      if (error.status === 400) {\n        if (error.code === B2_ERROR_CODES.INVALID_BUCKET_ID) {\n          const b2Error = new Error(`Invalid bucket ID: ${bucketId}`);\n          b2Error.code = B2_ERROR_CODES.INVALID_BUCKET_ID;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n        if (error.code === B2_ERROR_CODES.NOT_ALLOWED) {\n          const b2Error = new Error(\n            'Not allowed to create keys with the specified capabilities'\n          );\n          b2Error.code = B2_ERROR_CODES.NOT_ALLOWED;\n          b2Error.status = 400;\n          throw b2Error;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Delete an application key\n   * @param {Object|string} options - Key deletion options or key ID (for backward compatibility)\n   * @param {string} options.applicationKeyId - ID of the key to delete\n   * @returns {Promise<Object>} Key deletion response\n   */\n  async deleteKey(options) {\n    this.ensureAuthenticated();\n\n    // Handle backward compatibility: deleteKey(applicationKeyId)\n    let applicationKeyId;\n    if (typeof options === 'string') {\n      applicationKeyId = options;\n    } else if (options && typeof options === 'object') {\n      applicationKeyId = options.applicationKeyId;\n    } else {\n      throw new Error(\n        'Invalid arguments. Expected object with applicationKeyId or applicationKeyId as string'\n      );\n    }\n\n    // Validate inputs\n    this.validateKeyId(applicationKeyId);\n\n    const requestData = {\n      applicationKeyId: applicationKeyId,\n    };\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getDeleteKeyUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      // Handle specific B2 key deletion errors\n      if (error.status === 400) {\n        const b2Error = new Error(\n          `Invalid application key ID: ${applicationKeyId}`\n        );\n        b2Error.code = B2_ERROR_CODES.NOT_ALLOWED;\n        b2Error.status = 400;\n        throw b2Error;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * List application keys\n   * @param {Object} [options={}] - List options\n   * @param {number} [options.maxKeyCount] - Maximum number of keys to return (default 100, max 10000)\n   * @param {string} [options.startApplicationKeyId] - Key ID to start listing from (for pagination)\n   * @returns {Promise<Object>} List of keys response\n   */\n  async listKeys(options = {}) {\n    this.ensureAuthenticated();\n\n    if (options && typeof options !== 'object') {\n      throw new Error('options must be an object');\n    }\n\n    const { maxKeyCount, startApplicationKeyId } = options;\n\n    // Validate optional parameters\n    if (maxKeyCount !== undefined) {\n      if (\n        typeof maxKeyCount !== 'number' ||\n        maxKeyCount <= 0 ||\n        maxKeyCount > 10000\n      ) {\n        throw new Error('maxKeyCount must be a number between 1 and 10000');\n      }\n    }\n\n    if (startApplicationKeyId !== undefined) {\n      this.validateKeyId(startApplicationKeyId);\n    }\n\n    const requestData = {\n      accountId: this.authManager.getAccountId(),\n    };\n\n    // Add optional parameters if provided\n    if (maxKeyCount !== undefined) {\n      requestData.maxKeyCount = maxKeyCount;\n    }\n    if (startApplicationKeyId !== undefined) {\n      requestData.startApplicationKeyId = startApplicationKeyId;\n    }\n\n    try {\n      const response = await this.httpClient.post(\n        this.endpointBuilder.getListKeysUrl(),\n        requestData,\n        {\n          headers: this.authManager.getAuthHeaders(),\n          timeout: this.config.timeout,\n        }\n      );\n\n      return response;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n\n// Export key capabilities for convenience\nexport { KEY_CAPABILITIES };\n\nexport default KeyManager;\n","/**\n * B2Client - Main client class for Backblaze B2 API\n * Orchestrates all manager classes and provides the public API interface\n */\n\nimport { HttpClient } from './core/http-client.js';\nimport { RetryHandler } from './core/retry-handler.js';\nimport { AuthManager } from './managers/auth-manager.js';\nimport { BucketManager } from './managers/bucket-manager.js';\nimport { FileManager } from './managers/file-manager.js';\nimport { KeyManager } from './managers/key-manager.js';\nimport { DEFAULT_CONFIG, BUCKET_TYPES, KEY_CAPABILITIES, B2_API_BASE_URL } from './constants.js';\n\nexport class B2Client {\n  constructor(options = {}) {\n    // Validate options\n    if (options && typeof options !== 'object') {\n      throw new Error('options must be an object');\n    }\n\n    // Handle legacy constructor parameters for backward compatibility\n    this.accountId = options.accountId || null;\n    this.applicationKeyId = options.applicationKeyId || null;\n    this.applicationKey = options.applicationKey || null;\n    this.apiUrl = options.apiUrl || B2_API_BASE_URL;\n\n    // Legacy properties for backward compatibility\n    this.authorizationToken = null;\n    this.downloadUrl = null;\n\n    // Store configuration with proper mapping\n    this.config = {\n      timeout: options.timeout || DEFAULT_CONFIG.REQUEST_TIMEOUT,\n      retries: options.retries || DEFAULT_CONFIG.RETRY_ATTEMPTS,\n      retryDelay: options.retryDelay || DEFAULT_CONFIG.RETRY_DELAY,\n      retryDelayMultiplier: options.retryDelayMultiplier || DEFAULT_CONFIG.RETRY_DELAY_MULTIPLIER,\n      maxRetryDelay: options.maxRetryDelay || DEFAULT_CONFIG.MAX_RETRY_DELAY,\n      headers: options.headers || {},\n      ...options\n    };\n\n    // Initialize HTTP client with retry handler\n    const retryOptions = {\n      retries: this.config.retries,\n      retryDelay: this.config.retryDelay,\n      retryDelayMultiplier: this.config.retryDelayMultiplier,\n      maxRetryDelay: this.config.maxRetryDelay,\n    };\n\n    this.retryHandler = new RetryHandler(retryOptions);\n\n    const httpOptions = {\n      baseURL: this.config.apiUrl,\n      timeout: this.config.timeout,\n      headers: this.config.headers,\n    };\n\n    this.httpClient = new HttpClient(httpOptions);\n\n    // Initialize managers\n    this.authManager = new AuthManager(this.httpClient, this.config);\n    this.bucketManager = new BucketManager(\n      this.httpClient,\n      this.authManager,\n      this.config\n    );\n    this.fileManager = new FileManager(\n      this.httpClient,\n      this.authManager,\n      this.config\n    );\n    this.keyManager = new KeyManager(\n      this.httpClient,\n      this.authManager,\n      this.config\n    );\n\n    // Store credentials for potential re-authentication\n    this.credentials = null;\n\n    // Add backward compatibility constants as instance properties\n    this.BUCKET_TYPES = BUCKET_TYPES;\n    this.KEY_CAPABILITIES = KEY_CAPABILITIES;\n  }\n\n  // ===== AUTHENTICATION METHODS =====\n\n  /**\n   * Authorize with B2 API using application credentials\n   * @param {Object|string} options - Authentication options or applicationKeyId (for backward compatibility)\n   * @param {string} options.applicationKeyId - Application key ID\n   * @param {string} options.applicationKey - Application key\n   * @param {string} [applicationKey] - Application key (for backward compatibility when first param is string)\n   * @returns {Promise<Object>} Authentication response\n   */\n  async authorize(options, applicationKey) {\n    // Handle backward compatibility: authorize(applicationKeyId, applicationKey)\n    let credentials;\n    if (typeof options === 'string') {\n      credentials = {\n        applicationKeyId: options,\n        applicationKey: applicationKey,\n      };\n    } else if (options && typeof options === 'object') {\n      credentials = {\n        applicationKeyId: options.applicationKeyId,\n        applicationKey: options.applicationKey,\n      };\n    } else if (!options && this.applicationKeyId && this.applicationKey) {\n      // Use instance properties if no arguments provided (legacy behavior)\n      credentials = {\n        applicationKeyId: this.applicationKeyId,\n        applicationKey: this.applicationKey,\n      };\n    } else {\n      throw new Error(\n        'Invalid arguments. Expected object with applicationKeyId and applicationKey, or applicationKeyId and applicationKey as separate strings'\n      );\n    }\n\n    // Store credentials for potential re-authentication\n    this.credentials = credentials;\n\n    // Delegate to auth manager with retry handling\n    const response = await this.retryHandler.executeWithRetry(async () => {\n      return this.authManager.authorize(credentials, {\n        timeout: this.config.timeout,\n      });\n    });\n\n    // Update legacy instance properties for backward compatibility\n    if (response && response.data) {\n      this.authorizationToken = response.data.authorizationToken;\n      this.apiUrl = response.data.apiUrl;\n      this.downloadUrl = response.data.downloadUrl;\n    }\n\n    return response;\n  }\n\n  // ===== BUCKET METHODS =====\n\n  /**\n   * Create a new bucket\n   * @param {Object|string} options - Bucket creation options or bucket name (for backward compatibility)\n   * @param {string} options.bucketName - Name of the bucket to create\n   * @param {string} options.bucketType - Type of bucket (allPublic or allPrivate)\n   * @param {string} [bucketType] - Bucket type (for backward compatibility when first param is string)\n   * @returns {Promise<Object>} Bucket creation response\n   */\n  async createBucket(options, bucketType) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.bucketManager.create(options, bucketType);\n    });\n  }\n\n  /**\n   * Delete a bucket\n   * @param {Object|string} options - Bucket deletion options or bucket ID (for backward compatibility)\n   * @param {string} options.bucketId - ID of the bucket to delete\n   * @returns {Promise<Object>} Bucket deletion response\n   */\n  async deleteBucket(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.bucketManager.delete(options);\n    });\n  }\n\n  /**\n   * List buckets\n   * @param {Object} [options={}] - List options\n   * @returns {Promise<Object>} List of buckets response\n   */\n  async listBuckets(options = {}) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.bucketManager.list(options);\n    });\n  }\n\n  /**\n   * Get bucket information by name or ID\n   * @param {Object} options - Get bucket options\n   * @param {string} [options.bucketName] - Name of the bucket to get\n   * @param {string} [options.bucketId] - ID of the bucket to get\n   * @returns {Promise<Object>} Bucket information response\n   */\n  async getBucket(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.bucketManager.get(options);\n    });\n  }\n\n  /**\n   * Update bucket type\n   * @param {Object|string} options - Bucket update options or bucket ID (for backward compatibility)\n   * @param {string} options.bucketId - ID of the bucket to update\n   * @param {string} options.bucketType - New bucket type\n   * @param {string} [bucketType] - New bucket type (for backward compatibility when first param is string)\n   * @returns {Promise<Object>} Bucket update response\n   */\n  async updateBucket(options, bucketType) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.bucketManager.update(options, bucketType);\n    });\n  }\n\n  /**\n   * Get upload URL for a bucket\n   * @param {Object|string} options - Upload URL options or bucket ID (for backward compatibility)\n   * @param {string} options.bucketId - ID of the bucket to get upload URL for\n   * @returns {Promise<Object>} Upload URL response\n   */\n  async getUploadUrl(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.bucketManager.getUploadUrl(options);\n    });\n  }\n\n  // ===== FILE METHODS =====\n\n  /**\n   * Upload a file to B2\n   * @param {Object} options - Upload options\n   * @param {string} options.uploadUrl - Upload URL from getUploadUrl\n   * @param {string} options.uploadAuthToken - Upload authorization token\n   * @param {string} options.fileName - Name of the file\n   * @param {Buffer|Uint8Array|string} options.data - File data to upload\n   * @param {string} [options.contentType] - Content type (defaults to application/octet-stream)\n   * @param {string} [options.contentSha1] - SHA1 hash of content (will be calculated if not provided)\n   * @param {Object} [options.info] - File info metadata\n   * @param {Function} [options.onUploadProgress] - Progress callback function\n   * @returns {Promise<Object>} Upload response\n   */\n  async uploadFile(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.uploadFile(options);\n    });\n  }\n\n  /**\n   * Download a file by name\n   * @param {Object|string} options - Download options or bucket name (for backward compatibility)\n   * @param {string} options.bucketName - Name of the bucket containing the file\n   * @param {string} options.fileName - Name of the file to download\n   * @param {string} [options.responseType] - Response type: 'json', 'text', 'arraybuffer', 'blob', 'stream' (default: 'arraybuffer')\n   * @param {Function} [options.onDownloadProgress] - Progress callback function\n   * @param {Object} [options.headers] - Additional headers for the request\n   * @param {string} [fileName] - File name (for backward compatibility when first param is bucket name)\n   * @returns {Promise<Object>} Download response with file data\n   */\n  async downloadFileByName(options, fileName) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.downloadFileByName(options, fileName);\n    });\n  }\n\n  /**\n   * Download a file by ID\n   * @param {Object|string} options - Download options or file ID (for backward compatibility)\n   * @param {string} options.fileId - ID of the file to download\n   * @param {string} [options.responseType] - Response type: 'json', 'text', 'arraybuffer', 'blob', 'stream' (default: 'arraybuffer')\n   * @param {Function} [options.onDownloadProgress] - Progress callback function\n   * @param {Object} [options.headers] - Additional headers for the request\n   * @returns {Promise<Object>} Download response with file data\n   */\n  async downloadFileById(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.downloadFileById(options);\n    });\n  }\n\n  /**\n   * List file names in a bucket\n   * @param {Object} options - List options\n   * @param {string} options.bucketId - ID of the bucket to list files from\n   * @param {string} [options.startFileName] - File name to start listing from\n   * @param {number} [options.maxFileCount] - Maximum number of files to return (default: 100, max: 10000)\n   * @param {string} [options.prefix] - Only return file names that start with this prefix\n   * @param {string} [options.delimiter] - Delimiter for grouping file names\n   * @returns {Promise<Object>} List of file names response\n   */\n  async listFileNames(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.listFileNames(options);\n    });\n  }\n\n  /**\n   * List file versions in a bucket\n   * @param {Object} options - List options\n   * @param {string} options.bucketId - ID of the bucket to list file versions from\n   * @param {string} [options.startFileName] - File name to start listing from\n   * @param {string} [options.startFileId] - File ID to start listing from\n   * @param {number} [options.maxFileCount] - Maximum number of file versions to return (default: 100, max: 10000)\n   * @param {string} [options.prefix] - Only return file names that start with this prefix\n   * @param {string} [options.delimiter] - Delimiter for grouping file names\n   * @returns {Promise<Object>} List of file versions response\n   */\n  async listFileVersions(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.listFileVersions(options);\n    });\n  }\n\n  /**\n   * Get file information\n   * @param {Object|string} options - File info options or file ID (for backward compatibility)\n   * @param {string} options.fileId - ID of the file to get info for\n   * @returns {Promise<Object>} File information response\n   */\n  async getFileInfo(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.getFileInfo(options);\n    });\n  }\n\n  /**\n   * Delete a file version\n   * @param {Object} options - Delete options\n   * @param {string} options.fileId - ID of the file to delete\n   * @param {string} options.fileName - Name of the file to delete\n   * @returns {Promise<Object>} Delete response\n   */\n  async deleteFileVersion(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.deleteFileVersion(options);\n    });\n  }\n\n  /**\n   * Hide a file (make it invisible in file listings)\n   * @param {Object} options - Hide file options\n   * @param {string} options.bucketId - ID of the bucket containing the file\n   * @param {string} options.fileName - Name of the file to hide\n   * @returns {Promise<Object>} Hide file response\n   */\n  async hideFile(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.hideFile(options);\n    });\n  }\n\n  /**\n   * Get download authorization for private files\n   * @param {Object} options - Download authorization options\n   * @param {string} options.bucketId - ID of the bucket containing the files\n   * @param {string} options.fileNamePrefix - Prefix of file names to authorize (can be empty string for all files)\n   * @param {number} [options.validDurationInSeconds] - How long the authorization is valid (default: 604800 = 7 days, max: 604800)\n   * @param {string} [options.b2ContentDisposition] - Content-Disposition header value for downloads\n   * @returns {Promise<Object>} Download authorization response\n   */\n  async getDownloadAuthorization(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.getDownloadAuthorization(options);\n    });\n  }\n\n  // ===== LARGE FILE METHODS =====\n\n  /**\n   * Start a large file upload\n   * @param {Object} options - Start large file options\n   * @param {string} options.bucketId - ID of the bucket to upload to\n   * @param {string} options.fileName - Name of the file to upload\n   * @param {string} [options.contentType] - Content type (defaults to application/octet-stream)\n   * @param {Object} [options.fileInfo] - File info metadata\n   * @returns {Promise<Object>} Start large file response containing fileId\n   */\n  async startLargeFile(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.startLargeFile(options);\n    });\n  }\n\n  /**\n   * Get upload URL for a large file part\n   * @param {Object} options - Get upload part URL options\n   * @param {string} options.fileId - ID of the large file from startLargeFile\n   * @returns {Promise<Object>} Upload part URL response containing uploadUrl and authorizationToken\n   */\n  async getUploadPartUrl(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.getUploadPartUrl(options);\n    });\n  }\n\n  /**\n   * Upload a part of a large file\n   * @param {Object} options - Upload part options\n   * @param {string} options.uploadUrl - Upload URL from getUploadPartUrl\n   * @param {string} options.authorizationToken - Authorization token from getUploadPartUrl\n   * @param {number} options.partNumber - Part number (1-based, must be between 1 and 10000)\n   * @param {Buffer|Uint8Array|string} options.data - Part data to upload\n   * @param {string} [options.contentSha1] - SHA1 hash of part content (will be calculated if not provided)\n   * @param {Function} [options.onUploadProgress] - Progress callback function\n   * @returns {Promise<Object>} Upload part response\n   */\n  async uploadPart(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.uploadPart(options);\n    });\n  }\n\n  /**\n   * Finish a large file upload\n   * @param {Object} options - Finish large file options\n   * @param {string} options.fileId - ID of the large file from startLargeFile\n   * @param {Array<string>} options.partSha1Array - Array of SHA1 hashes for each part in order\n   * @returns {Promise<Object>} Finish large file response\n   */\n  async finishLargeFile(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.finishLargeFile(options);\n    });\n  }\n\n  /**\n   * Cancel a large file upload\n   * @param {Object} options - Cancel large file options\n   * @param {string} options.fileId - ID of the large file from startLargeFile\n   * @returns {Promise<Object>} Cancel large file response\n   */\n  async cancelLargeFile(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.cancelLargeFile(options);\n    });\n  }\n\n  /**\n   * List parts of a large file upload\n   * @param {Object} options - List parts options\n   * @param {string} options.fileId - ID of the large file from startLargeFile\n   * @param {number} [options.startPartNumber] - Part number to start listing from\n   * @param {number} [options.maxPartCount] - Maximum number of parts to return (default: 100, max: 10000)\n   * @returns {Promise<Object>} List parts response\n   */\n  async listParts(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.listParts(options);\n    });\n  }\n\n  /**\n   * List unfinished large file uploads\n   * @param {Object} options - List unfinished large files options\n   * @param {string} options.bucketId - ID of the bucket to list unfinished files from\n   * @param {string} [options.startFileId] - File ID to start listing from\n   * @param {number} [options.maxFileCount] - Maximum number of files to return (default: 100, max: 10000)\n   * @returns {Promise<Object>} List unfinished large files response\n   */\n  async listUnfinishedLargeFiles(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.fileManager.listUnfinishedLargeFiles(options);\n    });\n  }\n\n  // ===== KEY MANAGEMENT METHODS =====\n\n  /**\n   * Create a new application key\n   * @param {Object} options - Key creation options\n   * @param {string} options.keyName - Name for the new key\n   * @param {Array<string>} options.capabilities - Array of capabilities for the key\n   * @param {string} [options.bucketId] - Optional bucket ID to restrict key to specific bucket\n   * @param {string} [options.namePrefix] - Optional name prefix to restrict key to files with specific prefix\n   * @param {number} [options.validDurationInSeconds] - Optional duration in seconds for key validity\n   * @returns {Promise<Object>} Key creation response\n   */\n  async createKey(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.keyManager.createKey(options);\n    });\n  }\n\n  /**\n   * Delete an application key\n   * @param {Object|string} options - Key deletion options or key ID (for backward compatibility)\n   * @param {string} options.applicationKeyId - ID of the key to delete\n   * @returns {Promise<Object>} Key deletion response\n   */\n  async deleteKey(options) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.keyManager.deleteKey(options);\n    });\n  }\n\n  /**\n   * List application keys\n   * @param {Object} [options={}] - List options\n   * @param {number} [options.maxKeyCount] - Maximum number of keys to return (default 100, max 10000)\n   * @param {string} [options.startApplicationKeyId] - Key ID to start listing from (for pagination)\n   * @returns {Promise<Object>} List of keys response\n   */\n  async listKeys(options = {}) {\n    return this.retryHandler.executeWithRetry(async () => {\n      return this.keyManager.listKeys(options);\n    });\n  }\n\n  // ===== UTILITY METHODS =====\n\n  /**\n   * Check if currently authenticated\n   * @returns {boolean} True if authenticated\n   */\n  isAuthenticated() {\n    return this.authManager.isAuthenticated();\n  }\n\n  /**\n   * Get current authentication context\n   * @returns {Object} Current auth context\n   */\n  getAuthContext() {\n    return this.authManager.getAuthContext();\n  }\n\n  /**\n   * Clear authentication context\n   */\n  clearAuth() {\n    this.authManager.clearAuthContext();\n    this.credentials = null;\n\n    // Clear legacy instance properties\n    this.authorizationToken = null;\n    this.apiUrl = null;\n    this.downloadUrl = null;\n  }\n\n  /**\n   * Refresh authentication using stored credentials\n   * @returns {Promise<Object>} New authentication response\n   * @throws {Error} If no credentials are stored\n   */\n  async refreshAuth() {\n    if (!this.credentials) {\n      throw new Error('No credentials stored. Call authorize() first.');\n    }\n\n    return this.authorize(this.credentials);\n  }\n\n  /**\n   * Manually set authentication context from B2 API response\n   * @param {Object} authResponse - Authentication response from B2 API\n   * @param {string} authResponse.authorizationToken - Authorization token\n   * @param {string} authResponse.apiUrl - API URL for requests\n   * @param {string} authResponse.downloadUrl - Download URL for files\n   * @param {string} authResponse.accountId - Account ID\n   * @param {number} [authResponse.recommendedPartSize] - Recommended part size for large files\n   * @param {number} [authResponse.absoluteMinimumPartSize] - Minimum part size for large files\n   * @param {Object} [authResponse.allowed] - Allowed capabilities and restrictions\n   */\n  saveAuthContext(authResponse) {\n    // Delegate to auth manager\n    this.authManager.saveAuthContext(authResponse);\n\n    // Update legacy instance properties for backward compatibility\n    if (authResponse && typeof authResponse === 'object') {\n      this.authorizationToken = authResponse.authorizationToken || null;\n      this.apiUrl = authResponse.apiUrl || null;\n      this.downloadUrl = authResponse.downloadUrl || null;\n    }\n  }\n}\n\n// Export constants for backward compatibility\nexport { BUCKET_TYPES, KEY_CAPABILITIES };\n\nexport default B2Client;\n","/**\n * Comprehensive error handling system for B2 API\n * Provides error classification, formatting, and B2-specific error handling\n */\n\nimport {\n  HTTP_STATUS,\n  B2_ERROR_CODES,\n  RETRYABLE_STATUS_CODES,\n  RETRYABLE_ERROR_CODES,\n} from '../constants.js';\n\n/**\n * B2Error class extending Error with additional B2-specific properties\n */\nexport class B2Error extends Error {\n  constructor(message, options = {}) {\n    super(message);\n\n    this.name = 'B2Error';\n    this.status = options.status;\n    this.statusText = options.statusText;\n    this.code = options.code;\n    this.response = options.response;\n    this.request = options.request;\n    this.isRetryable = options.isRetryable ?? false;\n    this.isNetworkError = options.isNetworkError ?? false;\n    this.isHttpError = options.isHttpError ?? false;\n    this.retryAttempts = options.retryAttempts ?? 0;\n    this.isRetryExhausted = options.isRetryExhausted ?? false;\n\n    // Preserve stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, B2Error);\n    }\n  }\n\n  /**\n   * Convert error to JSON representation\n   * @returns {Object} JSON representation of the error\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      statusText: this.statusText,\n      code: this.code,\n      isRetryable: this.isRetryable,\n      isNetworkError: this.isNetworkError,\n      isHttpError: this.isHttpError,\n      retryAttempts: this.retryAttempts,\n      isRetryExhausted: this.isRetryExhausted,\n      stack: this.stack,\n    };\n  }\n\n  /**\n   * Get a human-readable description of the error\n   * @returns {string} Error description\n   */\n  getDescription() {\n    if (this.isNetworkError) {\n      return `Network error: ${this.message}`;\n    }\n\n    if (this.status) {\n      const statusInfo = this.statusText ? ` ${this.statusText}` : '';\n      const codeInfo = this.code ? ` (${this.code})` : '';\n      return `HTTP ${this.status}${statusInfo}${codeInfo}: ${this.message}`;\n    }\n\n    return this.message;\n  }\n}\n\n/**\n * Error Handler class for processing and classifying errors\n */\nexport class ErrorHandler {\n  constructor(options = {}) {\n    this.debug = options.debug ?? false;\n    this.logger = options.logger || console;\n  }\n\n  /**\n   * Determine if an error is retryable based on status code and error code\n   * @param {Error} error - Error to check\n   * @returns {boolean} Whether the error is retryable\n   */\n  isRetryable(error) {\n    // Network errors are generally retryable\n    if (error.isNetworkError) {\n      return true;\n    }\n\n    // Check HTTP status codes\n    if (error.status && RETRYABLE_STATUS_CODES.has(error.status)) {\n      return true;\n    }\n\n    // Check B2-specific error codes\n    if (error.code && RETRYABLE_ERROR_CODES.has(error.code)) {\n      return true;\n    }\n\n    // Server errors (5xx) are generally retryable\n    if (error.status >= 500 && error.status < 600) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Classify error type based on status code and error properties\n   * @param {Error} error - Error to classify\n   * @returns {string} Error classification\n   */\n  classifyError(error) {\n    if (error.isNetworkError) {\n      return 'NETWORK_ERROR';\n    }\n\n    if (!error.status) {\n      return 'UNKNOWN_ERROR';\n    }\n\n    if (error.status === HTTP_STATUS.UNAUTHORIZED) {\n      return 'AUTHENTICATION_ERROR';\n    }\n\n    if (error.status === HTTP_STATUS.FORBIDDEN) {\n      return 'AUTHORIZATION_ERROR';\n    }\n\n    if (error.status === HTTP_STATUS.NOT_FOUND) {\n      return 'NOT_FOUND_ERROR';\n    }\n\n    if (error.status === HTTP_STATUS.TOO_MANY_REQUESTS) {\n      return 'RATE_LIMIT_ERROR';\n    }\n\n    if (error.status === HTTP_STATUS.REQUEST_TIMEOUT) {\n      return 'TIMEOUT_ERROR';\n    }\n\n    if (error.status >= 400 && error.status < 500) {\n      return 'CLIENT_ERROR';\n    }\n\n    if (error.status >= 500 && error.status < 600) {\n      return 'SERVER_ERROR';\n    }\n\n    return 'HTTP_ERROR';\n  }\n\n  /**\n   * Parse B2 API error response\n   * @param {Object} response - HTTP response object\n   * @param {any} data - Response data\n   * @returns {Object} Parsed error information\n   */\n  parseB2ErrorResponse(response, data) {\n    let errorCode = null;\n    let errorMessage = null;\n\n    // Try to extract B2-specific error information\n    if (data && typeof data === 'object') {\n      errorCode = data.code || data.error_code || null;\n      errorMessage = data.message || data.error_message || data.error || null;\n    }\n\n    // Fallback to HTTP status information\n    if (!errorMessage) {\n      errorMessage = response.statusText || `HTTP ${response.status}`;\n    }\n\n    return {\n      code: errorCode,\n      message: errorMessage,\n      status: response.status,\n      statusText: response.statusText,\n    };\n  }\n\n  /**\n   * Create B2Error from HTTP response\n   * @param {Object} response - HTTP response object\n   * @param {any} data - Response data\n   * @param {Object} request - Original request information\n   * @returns {B2Error} Formatted B2Error\n   */\n  createHttpError(response, data, request = null) {\n    const errorInfo = this.parseB2ErrorResponse(response, data);\n    const isRetryable = this.isRetryable({\n      status: errorInfo.status,\n      code: errorInfo.code,\n    });\n\n    const error = new B2Error(errorInfo.message, {\n      status: errorInfo.status,\n      statusText: errorInfo.statusText,\n      code: errorInfo.code,\n      response: {\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n        data: data,\n      },\n      request: request,\n      isRetryable: isRetryable,\n      isHttpError: true,\n    });\n\n    if (this.debug) {\n      this.logger.error('HTTP Error:', error.toJSON());\n    }\n\n    return error;\n  }\n\n  /**\n   * Create B2Error from network error\n   * @param {Error} originalError - Original network error\n   * @param {Object} request - Original request information\n   * @returns {B2Error} Formatted B2Error\n   */\n  createNetworkError(originalError, request = null) {\n    let message = 'Network error occurred';\n    let code = 'NETWORK_ERROR';\n\n    if (originalError.name === 'AbortError') {\n      message = 'Request timeout';\n      code = 'TIMEOUT';\n    } else if (originalError.message) {\n      message = `Network error: ${originalError.message}`;\n    }\n\n    const error = new B2Error(message, {\n      code: code,\n      request: request,\n      isRetryable: true,\n      isNetworkError: true,\n    });\n\n    // Add originalError as a separate property\n    error.originalError = originalError;\n\n    if (this.debug) {\n      this.logger.error('Network Error:', error.toJSON());\n    }\n\n    return error;\n  }\n\n  /**\n   * Create B2Error from authentication failure\n   * @param {string} message - Error message\n   * @param {Object} response - HTTP response (optional)\n   * @returns {B2Error} Formatted B2Error\n   */\n  createAuthError(message, response = null) {\n    const error = new B2Error(message, {\n      status: HTTP_STATUS.UNAUTHORIZED,\n      statusText: 'Unauthorized',\n      code: B2_ERROR_CODES.BAD_AUTH_TOKEN,\n      response: response,\n      isRetryable: false,\n      isHttpError: true,\n    });\n\n    if (this.debug) {\n      this.logger.error('Authentication Error:', error.toJSON());\n    }\n\n    return error;\n  }\n\n  /**\n   * Create B2Error from validation failure\n   * @param {string} message - Error message\n   * @param {string} field - Field that failed validation (optional)\n   * @returns {B2Error} Formatted B2Error\n   */\n  createValidationError(message, field = null) {\n    const fullMessage = field\n      ? `Validation error for ${field}: ${message}`\n      : `Validation error: ${message}`;\n\n    const error = new B2Error(fullMessage, {\n      status: HTTP_STATUS.BAD_REQUEST,\n      statusText: 'Bad Request',\n      code: 'VALIDATION_ERROR',\n      isRetryable: false,\n      isHttpError: false,\n    });\n\n    // Add field as a separate property\n    if (field) {\n      error.field = field;\n    }\n\n    if (this.debug) {\n      this.logger.error('Validation Error:', error.toJSON());\n    }\n\n    return error;\n  }\n\n  /**\n   * Enhance existing error with additional context\n   * @param {Error} error - Original error\n   * @param {Object} context - Additional context\n   * @returns {B2Error} Enhanced error\n   */\n  enhanceError(error, context = {}) {\n    if (error instanceof B2Error) {\n      // Update existing B2Error with additional context\n      Object.assign(error, context);\n      return error;\n    }\n\n    // Convert regular Error to B2Error\n    const b2Error = new B2Error(error.message, {\n      ...context,\n      stack: error.stack,\n    });\n\n    // Add originalError as a separate property\n    b2Error.originalError = error;\n\n    return b2Error;\n  }\n\n  /**\n   * Format error for logging or display\n   * @param {Error} error - Error to format\n   * @param {boolean} includeStack - Whether to include stack trace\n   * @returns {Object} Formatted error information\n   */\n  formatError(error, includeStack = false) {\n    const formatted = {\n      type: this.classifyError(error),\n      message: error.message,\n      description:\n        error instanceof B2Error ? error.getDescription() : error.message,\n    };\n\n    if (error.status) {\n      formatted.status = error.status;\n      formatted.statusText = error.statusText;\n    }\n\n    if (error.code) {\n      formatted.code = error.code;\n    }\n\n    if (error.isRetryable !== undefined) {\n      formatted.isRetryable = error.isRetryable;\n    }\n\n    if (error.retryAttempts !== undefined) {\n      formatted.retryAttempts = error.retryAttempts;\n    }\n\n    if (includeStack && error.stack) {\n      formatted.stack = error.stack;\n    }\n\n    return formatted;\n  }\n\n  /**\n   * Log error with appropriate level based on error type\n   * @param {Error} error - Error to log\n   * @param {Object} context - Additional context for logging\n   */\n  logError(error, context = {}) {\n    if (!this.debug) {\n      return;\n    }\n\n    const formatted = this.formatError(error, true);\n    const logContext = { ...formatted, ...context };\n\n    if (error.isNetworkError || (error.status && error.status >= 500)) {\n      this.logger.error('B2 Error:', logContext);\n    } else if (error.status && error.status >= 400) {\n      this.logger.warn('B2 Client Error:', logContext);\n    } else {\n      this.logger.info('B2 Info:', logContext);\n    }\n  }\n\n  /**\n   * Check if error indicates expired authentication\n   * @param {Error} error - Error to check\n   * @returns {boolean} Whether error indicates expired auth\n   */\n  isAuthExpired(error) {\n    return (\n      error.status === HTTP_STATUS.UNAUTHORIZED ||\n      error.code === B2_ERROR_CODES.EXPIRED_AUTH_TOKEN ||\n      error.code === B2_ERROR_CODES.BAD_AUTH_TOKEN\n    );\n  }\n\n  /**\n   * Check if error indicates rate limiting\n   * @param {Error} error - Error to check\n   * @returns {boolean} Whether error indicates rate limiting\n   */\n  isRateLimited(error) {\n    return (\n      error.status === HTTP_STATUS.TOO_MANY_REQUESTS ||\n      error.code === B2_ERROR_CODES.TOO_MANY_REQUESTS\n    );\n  }\n\n  /**\n   * Get suggested retry delay for rate limited requests\n   * @param {Error} error - Rate limit error\n   * @returns {number} Suggested delay in milliseconds\n   */\n  getRateLimitDelay(error) {\n    // Check for Retry-After header\n    if (error.response && error.response.headers) {\n      const retryAfter = error.response.headers.get('Retry-After');\n      if (retryAfter) {\n        const delay = parseInt(retryAfter, 10);\n        if (!isNaN(delay)) {\n          return delay * 1000; // Convert seconds to milliseconds\n        }\n      }\n    }\n\n    // Default rate limit delay\n    return 60000; // 1 minute\n  }\n}\n\nexport default ErrorHandler;\n","import { BUCKET_TYPES, KEY_CAPABILITIES } from '../constants.js';\n\n/**\n * Input validation utilities for B2 API parameters\n */\nexport class Validator {\n  /**\n   * Validate required parameters\n   * @param {Object} params - Parameters object\n   * @param {string[]} required - Array of required parameter names\n   * @throws {Error} If any required parameter is missing\n   */\n  static validateRequired(params, required) {\n    if (!params || typeof params !== 'object') {\n      throw new Error('Parameters object is required');\n    }\n\n    const missing = required.filter(\n      (param) =>\n        params[param] === undefined ||\n        params[param] === null ||\n        params[param] === ''\n    );\n\n    if (missing.length > 0) {\n      throw new Error(`Missing required parameters: ${missing.join(', ')}`);\n    }\n  }\n\n  /**\n   * Validate string parameter\n   * @param {any} value - Value to validate\n   * @param {string} name - Parameter name for error messages\n   * @param {Object} options - Validation options\n   * @param {number} options.minLength - Minimum length\n   * @param {number} options.maxLength - Maximum length\n   * @param {RegExp} options.pattern - Pattern to match\n   * @throws {Error} If validation fails\n   */\n  static validateString(value, name, options = {}) {\n    if (typeof value !== 'string') {\n      throw new Error(`${name} must be a string`);\n    }\n\n    if (options.minLength !== undefined && value.length < options.minLength) {\n      throw new Error(\n        `${name} must be at least ${options.minLength} characters long`\n      );\n    }\n\n    if (options.maxLength !== undefined && value.length > options.maxLength) {\n      throw new Error(\n        `${name} must be no more than ${options.maxLength} characters long`\n      );\n    }\n\n    if (options.pattern && !options.pattern.test(value)) {\n      throw new Error(`${name} format is invalid`);\n    }\n  }\n\n  /**\n   * Validate number parameter\n   * @param {any} value - Value to validate\n   * @param {string} name - Parameter name for error messages\n   * @param {Object} options - Validation options\n   * @param {number} options.min - Minimum value\n   * @param {number} options.max - Maximum value\n   * @param {boolean} options.integer - Must be integer\n   * @throws {Error} If validation fails\n   */\n  static validateNumber(value, name, options = {}) {\n    if (typeof value !== 'number' || isNaN(value)) {\n      throw new Error(`${name} must be a valid number`);\n    }\n\n    if (options.integer && !Number.isInteger(value)) {\n      throw new Error(`${name} must be an integer`);\n    }\n\n    if (options.min !== undefined && value < options.min) {\n      throw new Error(`${name} must be at least ${options.min}`);\n    }\n\n    if (options.max !== undefined && value > options.max) {\n      throw new Error(`${name} must be no more than ${options.max}`);\n    }\n  }\n\n  /**\n   * Validate array parameter\n   * @param {any} value - Value to validate\n   * @param {string} name - Parameter name for error messages\n   * @param {Object} options - Validation options\n   * @param {number} options.minLength - Minimum array length\n   * @param {number} options.maxLength - Maximum array length\n   * @throws {Error} If validation fails\n   */\n  static validateArray(value, name, options = {}) {\n    if (!Array.isArray(value)) {\n      throw new Error(`${name} must be an array`);\n    }\n\n    if (options.minLength !== undefined && value.length < options.minLength) {\n      throw new Error(\n        `${name} must contain at least ${options.minLength} items`\n      );\n    }\n\n    if (options.maxLength !== undefined && value.length > options.maxLength) {\n      throw new Error(\n        `${name} must contain no more than ${options.maxLength} items`\n      );\n    }\n  }\n\n  /**\n   * Validate bucket name\n   * @param {string} bucketName - Bucket name to validate\n   * @throws {Error} If bucket name is invalid\n   */\n  static validateBucketName(bucketName) {\n    this.validateString(bucketName, 'bucketName', {\n      minLength: 6,\n      maxLength: 50,\n      pattern: /^[a-zA-Z0-9\\-]+$/,\n    });\n\n    // Additional B2-specific rules\n    if (bucketName.startsWith('-') || bucketName.endsWith('-')) {\n      throw new Error('Bucket name cannot start or end with a hyphen');\n    }\n\n    if (bucketName.includes('--')) {\n      throw new Error('Bucket name cannot contain consecutive hyphens');\n    }\n  }\n\n  /**\n   * Validate bucket type\n   * @param {string} bucketType - Bucket type to validate\n   * @throws {Error} If bucket type is invalid\n   */\n  static validateBucketType(bucketType) {\n    const validTypes = Object.values(BUCKET_TYPES);\n    if (!validTypes.includes(bucketType)) {\n      throw new Error(\n        `Invalid bucket type. Must be one of: ${validTypes.join(', ')}`\n      );\n    }\n  }\n\n  /**\n   * Validate file name\n   * @param {string} fileName - File name to validate\n   * @throws {Error} If file name is invalid\n   */\n  static validateFileName(fileName) {\n    this.validateString(fileName, 'fileName', {\n      minLength: 1,\n      maxLength: 1024,\n    });\n\n    // B2 doesn't allow certain characters in file names\n    const invalidChars = /[\\x00-\\x1f\\x7f]/;\n    if (invalidChars.test(fileName)) {\n      throw new Error('File name contains invalid control characters');\n    }\n\n    // File name cannot start with '/'\n    if (fileName.startsWith('/')) {\n      throw new Error('File name cannot start with a forward slash');\n    }\n  }\n\n  /**\n   * Validate SHA1 hash\n   * @param {string} sha1 - SHA1 hash to validate\n   * @throws {Error} If SHA1 hash is invalid\n   */\n  static validateSha1(sha1) {\n    this.validateString(sha1, 'SHA1 hash', {\n      minLength: 40,\n      maxLength: 40,\n      pattern: /^[a-fA-F0-9]{40}$/,\n    });\n  }\n\n  /**\n   * Validate content type\n   * @param {string} contentType - Content type to validate\n   * @throws {Error} If content type is invalid\n   */\n  static validateContentType(contentType) {\n    this.validateString(contentType, 'contentType', {\n      minLength: 1,\n      maxLength: 1024,\n      pattern:\n        /^[a-zA-Z0-9][a-zA-Z0-9!#$&\\-\\^_]*\\/[a-zA-Z0-9][a-zA-Z0-9!#$&\\-\\^_.]*$/,\n    });\n  }\n\n  /**\n   * Validate key capabilities\n   * @param {string[]} capabilities - Array of capabilities to validate\n   * @throws {Error} If any capability is invalid\n   */\n  static validateKeyCapabilities(capabilities) {\n    this.validateArray(capabilities, 'capabilities', { minLength: 1 });\n\n    const validCapabilities = Object.values(KEY_CAPABILITIES);\n    const invalid = capabilities.filter(\n      (cap) => !validCapabilities.includes(cap)\n    );\n\n    if (invalid.length > 0) {\n      throw new Error(`Invalid key capabilities: ${invalid.join(', ')}`);\n    }\n  }\n\n  /**\n   * Validate part number for multipart uploads\n   * @param {number} partNumber - Part number to validate\n   * @throws {Error} If part number is invalid\n   */\n  static validatePartNumber(partNumber) {\n    this.validateNumber(partNumber, 'partNumber', {\n      min: 1,\n      max: 10000,\n      integer: true,\n    });\n  }\n\n  /**\n   * Validate file size\n   * @param {number} size - File size in bytes\n   * @param {Object} options - Validation options\n   * @param {number} options.maxSize - Maximum allowed size\n   * @throws {Error} If file size is invalid\n   */\n  static validateFileSize(size, options = {}) {\n    this.validateNumber(size, 'file size', {\n      min: 0,\n      integer: true,\n    });\n\n    if (options.maxSize && size > options.maxSize) {\n      throw new Error(\n        `File size exceeds maximum allowed size of ${options.maxSize} bytes`\n      );\n    }\n  }\n\n  /**\n   * Validate pagination parameters\n   * @param {Object} params - Pagination parameters\n   * @param {number} params.maxFileCount - Maximum number of files to return\n   * @param {string} params.startFileName - File name to start listing from\n   * @throws {Error} If pagination parameters are invalid\n   */\n  static validatePagination(params) {\n    if (params.maxFileCount !== undefined) {\n      this.validateNumber(params.maxFileCount, 'maxFileCount', {\n        min: 1,\n        max: 10000,\n        integer: true,\n      });\n    }\n\n    if (params.startFileName !== undefined) {\n      this.validateFileName(params.startFileName);\n    }\n  }\n\n  /**\n   * Validate authentication credentials\n   * @param {Object} credentials - Authentication credentials\n   * @param {string} credentials.applicationKeyId - Application key ID\n   * @param {string} credentials.applicationKey - Application key\n   * @throws {Error} If credentials are invalid\n   */\n  static validateAuthCredentials(credentials) {\n    this.validateRequired(credentials, ['applicationKeyId', 'applicationKey']);\n\n    this.validateString(credentials.applicationKeyId, 'applicationKeyId', {\n      minLength: 1,\n      maxLength: 1024,\n    });\n\n    this.validateString(credentials.applicationKey, 'applicationKey', {\n      minLength: 1,\n      maxLength: 1024,\n    });\n  }\n}\n\n/**\n * URL encoding utilities\n */\nexport const UrlEncoder = {\n  /**\n   * Encode a file name for use in URLs, preserving path separators\n   * @param {string} fileName - File name to encode\n   * @returns {string} URL-encoded file name\n   */\n  encodeFileName(fileName) {\n    if (typeof fileName !== 'string') {\n      throw new Error('File name must be a string');\n    }\n\n    return fileName\n      .split('/')\n      .map((segment) => encodeURIComponent(segment))\n      .join('/');\n  },\n\n  /**\n   * Encode a single path segment\n   * @param {string} segment - Path segment to encode\n   * @returns {string} URL-encoded segment\n   */\n  encodePathSegment(segment) {\n    if (typeof segment !== 'string') {\n      throw new Error('Path segment must be a string');\n    }\n\n    return encodeURIComponent(segment);\n  },\n\n  /**\n   * Decode a URL-encoded file name\n   * @param {string} encodedFileName - Encoded file name\n   * @returns {string} Decoded file name\n   */\n  decodeFileName(encodedFileName) {\n    if (typeof encodedFileName !== 'string') {\n      throw new Error('Encoded file name must be a string');\n    }\n\n    try {\n      return encodedFileName\n        .split('/')\n        .map((segment) => decodeURIComponent(segment))\n        .join('/');\n    } catch (error) {\n      throw new Error(`Failed to decode file name: ${error.message}`);\n    }\n  },\n};\n\n/**\n * Parameter validation helpers for specific B2 operations\n */\nexport const B2Validators = {\n  /**\n   * Validate bucket creation parameters\n   * @param {Object} params - Bucket creation parameters\n   * @throws {Error} If parameters are invalid\n   */\n  validateCreateBucket(params) {\n    Validator.validateRequired(params, ['bucketName', 'bucketType']);\n    Validator.validateBucketName(params.bucketName);\n    Validator.validateBucketType(params.bucketType);\n\n    if (params.bucketInfo && typeof params.bucketInfo !== 'object') {\n      throw new Error('bucketInfo must be an object');\n    }\n\n    if (params.corsRules && !Array.isArray(params.corsRules)) {\n      throw new Error('corsRules must be an array');\n    }\n\n    if (params.lifecycleRules && !Array.isArray(params.lifecycleRules)) {\n      throw new Error('lifecycleRules must be an array');\n    }\n  },\n\n  /**\n   * Validate file upload parameters\n   * @param {Object} params - File upload parameters\n   * @throws {Error} If parameters are invalid\n   */\n  validateUploadFile(params) {\n    Validator.validateRequired(params, [\n      'uploadUrl',\n      'uploadAuthToken',\n      'fileName',\n      'data',\n    ]);\n    Validator.validateFileName(params.fileName);\n\n    if (params.contentType) {\n      Validator.validateContentType(params.contentType);\n    }\n\n    if (params.contentSha1) {\n      Validator.validateSha1(params.contentSha1);\n    }\n\n    if (params.info && typeof params.info !== 'object') {\n      throw new Error('info must be an object');\n    }\n  },\n\n  /**\n   * Validate large file start parameters\n   * @param {Object} params - Large file start parameters\n   * @throws {Error} If parameters are invalid\n   */\n  validateStartLargeFile(params) {\n    Validator.validateRequired(params, ['bucketId', 'fileName']);\n    Validator.validateFileName(params.fileName);\n\n    if (params.contentType) {\n      Validator.validateContentType(params.contentType);\n    }\n\n    if (params.info && typeof params.info !== 'object') {\n      throw new Error('info must be an object');\n    }\n  },\n\n  /**\n   * Validate part upload parameters\n   * @param {Object} params - Part upload parameters\n   * @throws {Error} If parameters are invalid\n   */\n  validateUploadPart(params) {\n    Validator.validateRequired(params, [\n      'uploadUrl',\n      'uploadAuthToken',\n      'partNumber',\n      'data',\n    ]);\n    Validator.validatePartNumber(params.partNumber);\n\n    if (params.contentSha1) {\n      Validator.validateSha1(params.contentSha1);\n    }\n  },\n\n  /**\n   * Validate key creation parameters\n   * @param {Object} params - Key creation parameters\n   * @throws {Error} If parameters are invalid\n   */\n  validateCreateKey(params) {\n    Validator.validateRequired(params, ['keyName', 'capabilities']);\n\n    Validator.validateString(params.keyName, 'keyName', {\n      minLength: 1,\n      maxLength: 100,\n    });\n\n    Validator.validateKeyCapabilities(params.capabilities);\n\n    if (params.validDurationInSeconds !== undefined) {\n      Validator.validateNumber(\n        params.validDurationInSeconds,\n        'validDurationInSeconds',\n        {\n          min: 1,\n          max: 1000 * 24 * 60 * 60, // 1000 days in seconds\n          integer: true,\n        }\n      );\n    }\n\n    if (params.bucketId) {\n      Validator.validateString(params.bucketId, 'bucketId');\n    }\n\n    if (params.namePrefix) {\n      Validator.validateString(params.namePrefix, 'namePrefix');\n    }\n  },\n};\n"],"names":["B2_API_BASE_URL","API_ENDPOINTS","BUCKET_TYPES","ALL_PRIVATE","ALL_PUBLIC","KEY_CAPABILITIES","LIST_KEYS","WRITE_KEYS","DELETE_KEYS","LIST_BUCKETS","WRITE_BUCKETS","DELETE_BUCKETS","LIST_ALL_BUCKET_NAMES","LIST_FILES","READ_FILES","SHARE_FILES","WRITE_FILES","DELETE_FILES","HTTP_STATUS","DEFAULT_CONFIG","B2_ERROR_CODES","RETRYABLE_ERROR_CODES","Set","RETRYABLE_STATUS_CODES","CONTENT_TYPES","JSON","OCTET_STREAM","HEADERS","ProgressHandler","constructor","options","this","createProgressEvent","loaded","total","lengthComputable","progress","percentage","Math","round","createUploadProgressTracker","onProgress","totalSize","chunk","length","byteLength","progressEvent","createDownloadProgressTracker","wrapUploadBody","body","progressTracker","bodyData","TextEncoder","encode","ArrayBuffer","Uint8Array","Buffer","ReadableStream","start","controller","offset","pump","close","slice","enqueue","setTimeout","wrapDownloadResponse","response","reader","getReader","read","then","done","value","catch","error","processResponseWithProgress","responseType","onDownloadProgress","processResponseWithoutProgress","contentLength","parseInt","headers","get","progressStream","progressResponse","Response","status","statusText","blob","arrayBuffer","text","json","contentType","includes","calculateBodySize","Blob","size","FormData","validateProgressCallback","callback","undefined","Error","createThrottledProgressCallback","throttleMs","lastCallTime","now","Date","HttpClient","timeout","baseURL","defaultHeaders","progressHandler","performanceMetrics","enabled","enablePerformanceMetrics","requestCount","totalRequestTime","averageRequestTime","slowRequests","errorCount","startPerformanceTimer","method","url","startTime","performance","startMemory","process","memoryUsage","endPerformanceTimer","timer","isError","duration","endMemory","push","timestamp","toISOString","memoryDelta","heapUsed","shift","getPerformanceMetrics","resetPerformanceMetrics","createAbortController","AbortController","abort","transformResponse","data","config","shouldUseStreaming","optimizeUploadData","end","min","parseResponseData","createHttpError","isHttpError","code","message","request","onUploadProgress","perfTimer","fullUrl","startsWith","requestHeaders","stringify","bodySize","uploadTracker","fetchOptions","toUpperCase","signal","fetch","ok","responseData","name","timeoutError","isNetworkError","networkError","originalError","post","put","RetryHandler","retries","retryDelay","retryDelayMultiplier","maxRetryDelay","retryCondition","defaultRetryCondition","bind","onRetry","attempt","has","calculateDelay","exponentialDelay","pow","cappedDelay","jitterRange","jitter","random","max","sleep","ms","Promise","resolve","executeWithRetry","requestFn","maxAttempts","lastError","shouldRetry","retryAttempts","isRetryExhausted","delay","wrap","fn","args","isRetryable","getConfig","updateConfig","AuthHeaders","createBasicAuth","applicationKeyId","applicationKey","credentials","btoa","HEADERS_AUTHORIZATION","createBearerAuth","token","extractAuthToken","InfoHeaders","MAX_INFO_HEADERS","addInfoHeaders","info","keys","Object","invalidKeys","updatedHeaders","forEach","key","isValidInfoHeaderKey","encodeURIComponent","String","join","test","extractInfoHeaders","entries","toLowerCase","infoKey","substring","decodeURIComponent","HeaderUtils","createJsonHeaders","authToken","HEADERS_CONTENT_TYPE","createUploadHeaders","fileName","contentSha1","createPartUploadHeaders","partNumber","normalizeHeaders","normalized","convertBzHeaders","result","camelKey","toCamelCase","str","split","map","word","index","charAt","AuthManager","httpClient","authContext","authorizationToken","apiUrl","downloadUrl","accountId","recommendedPartSize","absoluteMinimumPartSize","allowed","isAuthenticated","validateCredentials","hasOwnProperty","trim","generateBasicAuthHeader","saveAuthContext","authResponse","apiInfo","storageApi","requiredFields","field","getAuthContext","getAuthToken","getApiUrl","getDownloadUrl","getAccountId","getRecommendedPartSize","clearAuthContext","authorize","authHeaders","b2Error","isAuthError","getAuthHeaders","refreshAuth","isAuthExpiredError","EndpointBuilder","setAuthContext","buildApiUrl","endpoint","params","baseUrl","URL","searchParams","append","toString","buildDownloadUrl","getAuthorizeAccountUrl","getCreateBucketUrl","getDeleteBucketUrl","getListBucketsUrl","getUpdateBucketUrl","getUploadUrl","getListFileNamesUrl","getListFileVersionsUrl","getFileInfoUrl","getDeleteFileVersionUrl","getHideFileUrl","getDownloadFileByNameUrl","bucketName","encodedFileName","getDownloadFileByIdUrl","fileId","getStartLargeFileUrl","getUploadPartUrlEndpoint","getFinishLargeFileUrl","getCancelLargeFileUrl","getListPartsUrl","getListUnfinishedLargeFilesUrl","getCreateKeyUrl","getDeleteKeyUrl","getListKeysUrl","getDownloadAuthorizationUrl","BucketManager","authManager","endpointBuilder","validateBucketName","validateBucketType","bucketType","validTypes","values","validateBucketId","bucketId","ensureAuthenticated","create","type","requestData","list","update","isNode","versions","node","crypto","cryptoPromise","getCrypto","import","cryptoModule","globalThis","Sha1Hasher","hash","hashNode","hashBrowser","createHash","digest","hashBuffer","subtle","hashArray","Array","from","byte","padStart","createStream","Sha1Stream","verify","expectedHash","hashFile","filePath","stream","createReadStream","hasher","reject","on","chunks","init","totalLength","reduce","sum","combined","set","FileManager","validateFileName","validateFileId","uploadFile","uploadUrl","uploadAuthToken","sha1Hash","uploadTimeout","getFileInfo","deleteFileVersion","listFileNames","startFileName","maxFileCount","prefix","delimiter","listFileVersions","startFileId","hideFile","downloadFileByName","actualFileName","validResponseTypes","downloadTimeout","downloadFileById","getDownloadAuthorization","fileNamePrefix","validDurationInSeconds","b2ContentDisposition","startLargeFile","fileInfo","getUploadPartUrl","uploadPart","MAX_PART_SIZE","Authorization","finishLargeFile","partSha1Array","isArray","sha1","cancelLargeFile","listParts","startPartNumber","maxPartCount","listUnfinishedLargeFiles","KeyManager","validateKeyName","keyName","validateCapabilities","capabilities","validCapabilities","capability","validateKeyId","validateNamePrefix","namePrefix","createKey","deleteKey","listKeys","maxKeyCount","startApplicationKeyId","B2Client","retryOptions","retryHandler","httpOptions","bucketManager","fileManager","keyManager","async","createBucket","deleteBucket","delete","listBuckets","getBucket","updateBucket","clearAuth","B2Error","super","captureStackTrace","toJSON","stack","getDescription","statusInfo","codeInfo","debug","logger","console","classifyError","parseB2ErrorResponse","errorCode","errorMessage","error_code","error_message","errorInfo","createNetworkError","createAuthError","createValidationError","enhanceError","context","assign","formatError","includeStack","formatted","description","logError","logContext","warn","isAuthExpired","isRateLimited","getRateLimitDelay","retryAfter","isNaN","validateRequired","required","missing","filter","param","validateString","minLength","maxLength","pattern","validateNumber","integer","Number","isInteger","validateArray","endsWith","validateSha1","validateContentType","validateKeyCapabilities","invalid","cap","validatePartNumber","validateFileSize","maxSize","validatePagination","validateAuthCredentials"],"mappings":"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"}