"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const t="https://api.backblazeb2.com",e="/b2api/v4/b2_authorize_account",r="/b2api/v2/b2_create_bucket",i="/b2api/v2/b2_delete_bucket",a="/b2api/v2/b2_list_buckets",s="/b2api/v2/b2_update_bucket",n="/b2api/v2/b2_get_upload_url",o="/b2api/v2/b2_download_file_by_id",u="/file",h="/b2api/v2/b2_list_file_names",l="/b2api/v2/b2_list_file_versions",c="/b2api/v2/b2_get_file_info",d="/b2api/v2/b2_delete_file_version",p="/b2api/v2/b2_hide_file",f="/b2api/v2/b2_start_large_file",y="/b2api/v2/b2_get_upload_part_url",w="/b2api/v2/b2_finish_large_file",g="/b2api/v2/b2_cancel_large_file",m="/b2api/v2/b2_list_parts",b="/b2api/v2/b2_list_unfinished_large_files",E="/b2api/v2/b2_create_key",I="/b2api/v2/b2_delete_key",k="/b2api/v2/b2_list_keys",v="/b2api/v2/b2_get_download_authorization",A={ALL_PRIVATE:"allPrivate",ALL_PUBLIC:"allPublic"},x={LIST_KEYS:"listKeys",WRITE_KEYS:"writeKeys",DELETE_KEYS:"deleteKeys",LIST_BUCKETS:"listBuckets",WRITE_BUCKETS:"writeBuckets",DELETE_BUCKETS:"deleteBuckets",LIST_ALL_BUCKET_NAMES:"listAllBucketNames",LIST_FILES:"listFiles",READ_FILES:"readFiles",SHARE_FILES:"shareFiles",WRITE_FILES:"writeFiles",DELETE_FILES:"deleteFiles"},U=400,T=401,C=403,R=404,N=408,M=429,F=500,B=502,_=503,S=504,D=3,L=1e3,H=2,P=3e4,$=3e4,j=1e4,z="bad_auth_token",K="expired_auth_token",q="invalid_bucket_id",O="invalid_bucket_name",W="bucket_not_empty",V="duplicate_bucket_name",J="file_not_present",X="not_allowed",Z="too_many_requests",Y=new Set(["request_timeout",Z]),G=new Set([N,M,F,B,_,S]),Q={JSON:"application/json",OCTET_STREAM:"application/octet-stream"},tt="Authorization",et="Content-Type",rt="Content-Length",it="X-Bz-Content-Sha1",at="X-Bz-File-Name",st="X-Bz-Part-Number";class nt{constructor(t={}){this.options=t}createProgressEvent(t,e,r=!0){return{loaded:t,total:e,lengthComputable:r,progress:r&&e>0?t/e:0,percentage:r&&e>0?Math.round(t/e*100):0}}createUploadProgressTracker(t,e){if("function"!=typeof t)return null;let r=0;return i=>{i&&(r+=i.length||i.byteLength||0);const a=this.createProgressEvent(r,e,e>0);t(a)}}createDownloadProgressTracker(t,e){if("function"!=typeof t)return null;let r=0;return i=>{i&&(r+=i.length||i.byteLength||0);const a=this.createProgressEvent(r,e,e>0);t(a)}}wrapUploadBody(t,e){if(!e||!t)return t;let r;if("string"==typeof t)r=(new TextEncoder).encode(t);else if(t instanceof ArrayBuffer)r=new Uint8Array(t);else{if(!(t instanceof Uint8Array||t instanceof Buffer))return t;r=t}return new ReadableStream({start(t){let i=0;const a=()=>{if(i>=r.length)return void t.close();const s=r.slice(i,i+65536);t.enqueue(s),e(s),i+=s.length,setTimeout(a,0)};a()}})}wrapDownloadResponse(t,e){if(!e||!t.body)return t.body;const r=t.body.getReader();return new ReadableStream({start(t){const i=()=>r.read().then(({done:r,value:a})=>{if(!r)return e(a),t.enqueue(a),i();t.close()}).catch(e=>{t.error(e)});return i()}})}async processResponseWithProgress(t,e,r){if(!r||!t.body)return this.processResponseWithoutProgress(t,e);const i=parseInt(t.headers.get("content-length")||"0",10),a=this.createDownloadProgressTracker(r,i),s=this.wrapDownloadResponse(t,a),n=new Response(s,{status:t.status,statusText:t.statusText,headers:t.headers});return this.processResponseWithoutProgress(n,e)}async processResponseWithoutProgress(t,e){switch(e){case"stream":return t.body;case"blob":return await t.blob();case"arraybuffer":return await t.arrayBuffer();case"text":return await t.text();case"json":return await t.json();default:const e=t.headers.get("content-type")||"";if(e.includes("application/json"))try{return await t.json()}catch(r){return await t.text()}return e.includes("text/")?await t.text():await t.arrayBuffer()}}calculateBodySize(t){return t?"string"==typeof t?(new TextEncoder).encode(t).length:t instanceof ArrayBuffer?t.byteLength:t instanceof Uint8Array||t instanceof Buffer?t.length:t instanceof Blob?t.size:t instanceof FormData?0:t.length||t.size||0:0}validateProgressCallback(t){if(void 0!==t&&"function"!=typeof t)throw new Error("Progress callback must be a function")}createThrottledProgressCallback(t,e=100){if(!t||"function"!=typeof t)return null;let r=0;return i=>{const a=Date.now();(0===r||i.progress>=1||a-r>=e)&&(r=a,t(i))}}}class ot{constructor(t={}){this.timeout=t.timeout||$,this.baseURL=t.baseURL||"",this.defaultHeaders=t.headers||{},this.progressHandler=new nt(t.progress||{}),this.performanceMetrics={enabled:t.enablePerformanceMetrics||!1,requestCount:0,totalRequestTime:0,averageRequestTime:0,slowRequests:[],errorCount:0}}startPerformanceTimer(t,e){return this.performanceMetrics.enabled?{method:t,url:e,startTime:performance.now(),startMemory:process.memoryUsage?.()||null}:null}endPerformanceTimer(t,e=!1){if(!t||!this.performanceMetrics.enabled)return;const r=performance.now()-t.startTime,i=process.memoryUsage?.()||null;this.performanceMetrics.requestCount++,this.performanceMetrics.totalRequestTime+=r,this.performanceMetrics.averageRequestTime=this.performanceMetrics.totalRequestTime/this.performanceMetrics.requestCount,e&&this.performanceMetrics.errorCount++,r>5e3&&(this.performanceMetrics.slowRequests.push({method:t.method,url:t.url,duration:r,timestamp:(new Date).toISOString(),memoryDelta:i&&t.startMemory?i.heapUsed-t.startMemory.heapUsed:null}),this.performanceMetrics.slowRequests.length>10&&this.performanceMetrics.slowRequests.shift())}getPerformanceMetrics(){return{...this.performanceMetrics}}resetPerformanceMetrics(){this.performanceMetrics={...this.performanceMetrics,requestCount:0,totalRequestTime:0,averageRequestTime:0,slowRequests:[],errorCount:0}}createAbortController(t){const e=new AbortController;return t>0&&setTimeout(()=>{e.abort()},t),e}transformResponse(t,e){return{status:t.status,statusText:t.statusText,headers:t.headers,data:e,config:{url:t.url,method:t.method||"GET"}}}shouldUseStreaming(t,e){const r=t.headers.get("content-length");return"stream"===e||r&&parseInt(r)>52428800||t.headers.get("content-type")?.includes("application/octet-stream")}optimizeUploadData(t){return t instanceof ArrayBuffer&&t.byteLength>10485760?new ReadableStream({start(e){const r=new Uint8Array(t);let i=0;const a=()=>{if(i<r.length){const t=Math.min(i+65536,r.length);e.enqueue(r.slice(i,t)),i=t,setTimeout(a,0)}else e.close()};a()}}):t}async parseResponseData(t,e="auto"){return await this.progressHandler.processResponseWithoutProgress(t,e)}async createHttpError(t,e){const r=new Error(`HTTP ${t.status}: ${t.statusText}`);return r.status=t.status,r.statusText=t.statusText,r.response=this.transformResponse(t,e),r.isHttpError=!0,e&&"object"==typeof e&&(e.code&&(r.code=e.code),e.message&&(r.message=e.message)),r}async request(t={}){const{method:e="GET",url:r,data:i,headers:a={},timeout:s=this.timeout,responseType:n="auto",onUploadProgress:o,onDownloadProgress:u}=t,h=this.startPerformanceTimer(e,r);this.progressHandler.validateProgressCallback(o),this.progressHandler.validateProgressCallback(u);const l=r.startsWith("http")?r:`${this.baseURL}${r}`,c={...this.defaultHeaders,...a};let d=null;if(void 0!==i&&"GET"!==e&&"HEAD"!==e&&(i instanceof FormData||i instanceof ArrayBuffer||i instanceof Blob?d=this.optimizeUploadData(i):"object"==typeof i?(d=JSON.stringify(i),c["Content-Type"]||(c["Content-Type"]=Q.JSON)):d=i,o&&d)){const t=this.progressHandler.calculateBodySize(d),e=this.progressHandler.createUploadProgressTracker(o,t);e&&(d=this.progressHandler.wrapUploadBody(d,e))}const p=this.createAbortController(s),f={method:e.toUpperCase(),headers:c,body:d,signal:p.signal};try{const t=await fetch(l,f);if(!t.ok){const e=await this.parseResponseData(t,n);throw await this.createHttpError(t,e)}const e=await this.progressHandler.processResponseWithProgress(t,n,u);return this.endPerformanceTimer(h,!1),this.transformResponse(t,e)}catch(y){if(this.endPerformanceTimer(h,!0),"AbortError"===y.name){const t=new Error(`Request timeout after ${s}ms`);throw t.code="TIMEOUT",t.isNetworkError=!0,t}if(y.isHttpError)throw y;const t=new Error(`Network error: ${y.message}`);throw t.code="NETWORK_ERROR",t.isNetworkError=!0,t.originalError=y,t}}async get(t,e={}){return this.request({method:"GET",url:t,...e})}async post(t,e,r={}){return this.request({method:"POST",url:t,data:e,...r})}async put(t,e,r={}){return this.request({method:"PUT",url:t,data:e,...r})}async delete(t,e={}){return this.request({method:"DELETE",url:t,...e})}}class ut{constructor(t={}){this.retries=t.retries??D,this.retryDelay=t.retryDelay??L,this.retryDelayMultiplier=t.retryDelayMultiplier??H,this.maxRetryDelay=t.maxRetryDelay??P,this.retryCondition=t.retryCondition||this.defaultRetryCondition.bind(this),this.onRetry=t.onRetry||null}defaultRetryCondition(t,e){return!(e>=this.retries)&&(!!t.isNetworkError||(!(!t.status||!G.has(t.status))||(!(!t.code||!Y.has(t.code))||!(t.status>=400&&t.status<500&&t.status!==M)&&t.status>=500)))}calculateDelay(t){const e=this.retryDelay*Math.pow(this.retryDelayMultiplier,t),r=Math.min(e,this.maxRetryDelay),i=.25*r,a=2*(Math.random()-.5)*i;return Math.max(0,Math.round(r+a))}sleep(t){return new Promise(e=>setTimeout(e,t))}async executeWithRetry(t,e={}){const r=(e.retries??this.retries)+1;let i;for(let s=0;s<r;s++)try{return await t()}catch(a){i=a;const t=this.retryCondition(a,s);if(s===r-1||!t)throw a.retryAttempts=s+1,a.isRetryExhausted=s===r-1,a;const e=this.calculateDelay(s);this.onRetry&&this.onRetry(a,s+1,e),e>0&&await this.sleep(e)}throw i}wrap(t,e={}){return(...r)=>this.executeWithRetry(()=>t(...r),e)}isRetryable(t){return this.retryCondition(t,0)}getConfig(){return{retries:this.retries,retryDelay:this.retryDelay,retryDelayMultiplier:this.retryDelayMultiplier,maxRetryDelay:this.maxRetryDelay}}updateConfig(t={}){void 0!==t.retries&&(this.retries=t.retries),void 0!==t.retryDelay&&(this.retryDelay=t.retryDelay),void 0!==t.retryDelayMultiplier&&(this.retryDelayMultiplier=t.retryDelayMultiplier),void 0!==t.maxRetryDelay&&(this.maxRetryDelay=t.maxRetryDelay),void 0!==t.retryCondition&&(this.retryCondition=t.retryCondition),void 0!==t.onRetry&&(this.onRetry=t.onRetry)}}const ht={createBasicAuth(t,e){if(!t||!e)throw new Error("Application key ID and application key are required for Basic auth");const r=btoa(`${t}:${e}`);return{[tt]:`Basic ${r}`}},createBearerAuth(t){if(!t)throw new Error("Token is required for Bearer auth");return{[tt]:t}},extractAuthToken:t=>t?.[tt]||null},lt={MAX_INFO_HEADERS:10,addInfoHeaders(t,e){if(!e||"object"!=typeof e)return t;const r=Object.keys(e);if(r.length>this.MAX_INFO_HEADERS)throw new Error(`Too many info headers: maximum of ${this.MAX_INFO_HEADERS} allowed`);const i=[],a={...t};if(r.forEach(t=>{if(this.isValidInfoHeaderKey(t)){a[`X-Bz-Info-${t}`]=encodeURIComponent(String(e[t]))}else i.push(t)}),i.length>0)throw new Error(`Info header keys contain invalid characters: ${i.join(", ")}`);return a},isValidInfoHeaderKey:t=>"string"==typeof t&&/^[a-zA-Z0-9\-_]+$/.test(t),extractInfoHeaders(t){const e={};return t&&"object"==typeof t?(Object.entries(t).forEach(([t,r])=>{if(t.toLowerCase().startsWith("x-bz-info-")){const a=t.substring(10);try{e[a]=decodeURIComponent(r)}catch(i){e[a]=r}}}),e):e}},ct={createJsonHeaders(t){const e={[et]:Q.JSON};return t&&(e[tt]=t),e},createUploadHeaders({authToken:t,fileName:e,contentType:r,contentSha1:i,contentLength:a,info:s}){let n={};return t&&(n[tt]=t),e&&(n[at]=encodeURIComponent(e)),r&&(n[et]=r),i&&(n[it]=i),void 0!==a&&(n[rt]=String(a)),s&&(n=lt.addInfoHeaders(n,s)),n},createPartUploadHeaders({authToken:t,partNumber:e,contentSha1:r,contentLength:i}){const a={};return t&&(a[tt]=t),void 0!==e&&(a[st]=String(e)),r&&(a[it]=r),void 0!==i&&(a[rt]=String(i)),a},normalizeHeaders(t){if(!t||"object"!=typeof t)return{};const e={};return Object.entries(t).forEach(([t,r])=>{e[t.toLowerCase()]=r}),e},convertBzHeaders(t){const e={};return t&&"object"==typeof t?(Object.entries(t).forEach(([t,r])=>{if(t.toLowerCase().startsWith("x-bz-")){let i;i=t.toLowerCase().startsWith("x-bz-info-")?"info"+this.toCamelCase(t.substring(11)):this.toCamelCase(t.substring(5)),e[i]=r}}),e):e},toCamelCase:t=>t.split("-").map((t,e)=>0===e?t.toLowerCase():t.charAt(0).toUpperCase()+t.slice(1).toLowerCase()).join("")};class dt{constructor(t,e={}){this.httpClient=t,this.config=e,this.authContext={authorizationToken:null,apiUrl:null,downloadUrl:null,accountId:null,recommendedPartSize:null,absoluteMinimumPartSize:null,allowed:null,isAuthenticated:!1}}validateCredentials(t){if(!t||"object"!=typeof t)throw new Error("credentials is required");if(!t.hasOwnProperty("applicationKeyId"))throw new Error("applicationKeyId is required");if(!t.hasOwnProperty("applicationKey"))throw new Error("applicationKey is required");if("string"!=typeof t.applicationKeyId)throw new Error("applicationKeyId must be a string");if("string"!=typeof t.applicationKey)throw new Error("applicationKey must be a string");if(0===t.applicationKeyId.trim().length)throw new Error("Application key ID cannot be empty");if(0===t.applicationKey.trim().length)throw new Error("Application key cannot be empty")}generateBasicAuthHeader(t,e){try{return ht.createBasicAuth(t,e)}catch(r){throw new Error(`Failed to generate Basic auth header: ${r.message}`)}}saveAuthContext(t){if(!t||"object"!=typeof t)throw new Error("Invalid authentication response");let e,r,i,a,s;if(t.apiInfo&&t.apiInfo.storageApi){const n=t.apiInfo.storageApi;e=n.apiUrl,r=n.downloadUrl,i=n.recommendedPartSize,a=n.absoluteMinimumPartSize,s=n.allowed}else e=t.apiUrl,r=t.downloadUrl,i=t.recommendedPartSize,a=t.absoluteMinimumPartSize,s=t.allowed;const n=[{name:"authorizationToken",value:t.authorizationToken},{name:"apiUrl",value:e},{name:"downloadUrl",value:r},{name:"accountId",value:t.accountId}];for(const o of n)if(!o.value)throw new Error(`Missing required field in auth response: ${o.name}`);this.authContext={authorizationToken:t.authorizationToken,apiUrl:e,downloadUrl:r,accountId:t.accountId,recommendedPartSize:i||null,absoluteMinimumPartSize:a||null,allowed:s||null,isAuthenticated:!0}}getAuthContext(){return{...this.authContext}}isAuthenticated(){return this.authContext.isAuthenticated&&!!this.authContext.authorizationToken}getAuthToken(){return this.authContext.authorizationToken}getApiUrl(){return this.authContext.apiUrl}getDownloadUrl(){return this.authContext.downloadUrl}getAccountId(){return this.authContext.accountId}getRecommendedPartSize(){return this.authContext.recommendedPartSize}clearAuthContext(){this.authContext={authorizationToken:null,apiUrl:null,downloadUrl:null,accountId:null,recommendedPartSize:null,absoluteMinimumPartSize:null,allowed:null,isAuthenticated:!1}}async authorize(r,i={}){this.validateCredentials(r);const a=this.generateBasicAuthHeader(r.applicationKeyId,r.applicationKey);try{const r=await this.httpClient.get(`${t}${e}`,{headers:a,timeout:i.timeout});return this.saveAuthContext(r.data),r}catch(s){if(this.clearAuthContext(),401===s.status){const t=new Error("Authentication failed: Invalid application key ID or application key");throw t.code=z,t.status=401,t.isAuthError=!0,t.response=s.response,t}throw s}}getAuthHeaders(){if(!this.isAuthenticated())throw new Error("Not authenticated. Call authorize() first.");return ht.createBearerAuth(this.authContext.authorizationToken)}async refreshAuth(t,e={}){return this.clearAuthContext(),this.authorize(t,e)}isAuthExpiredError(t){return 401===t.status||t.code===z||t.code===K}}class pt{constructor(t=null){this.authContext=t}setAuthContext(t){this.authContext=t}getApiUrl(){return this.authContext?.apiUrl||t}getDownloadUrl(){if(!this.authContext?.downloadUrl)throw new Error("Download URL not available. Please authenticate first.");return this.authContext.downloadUrl}buildApiUrl(t,e={}){const r=this.getApiUrl(),i=new URL(t,r);return Object.entries(e).forEach(([t,e])=>{null!=e&&i.searchParams.append(t,String(e))}),i.toString()}buildDownloadUrl(t,e={}){const r=this.getDownloadUrl(),i=new URL(t,r);return Object.entries(e).forEach(([t,e])=>{null!=e&&i.searchParams.append(t,String(e))}),i.toString()}getAuthorizeAccountUrl(){return this.buildApiUrl(e)}getCreateBucketUrl(){return this.buildApiUrl(r)}getDeleteBucketUrl(){return this.buildApiUrl(i)}getListBucketsUrl(){return this.buildApiUrl(a)}getUpdateBucketUrl(){return this.buildApiUrl(s)}getUploadUrl(){return this.buildApiUrl(n)}getListFileNamesUrl(){return this.buildApiUrl(h)}getListFileVersionsUrl(){return this.buildApiUrl(l)}getFileInfoUrl(){return this.buildApiUrl(c)}getDeleteFileVersionUrl(){return this.buildApiUrl(d)}getHideFileUrl(){return this.buildApiUrl(p)}getDownloadFileByNameUrl(t,e){const r=encodeURIComponent(e),i=`${u}/${encodeURIComponent(t)}/${r}`;return this.buildDownloadUrl(i)}getDownloadFileByIdUrl(t){return this.buildDownloadUrl(o,{fileId:t})}getStartLargeFileUrl(){return this.buildApiUrl(f)}getUploadPartUrlEndpoint(){return this.buildApiUrl(y)}getFinishLargeFileUrl(){return this.buildApiUrl(w)}getCancelLargeFileUrl(){return this.buildApiUrl(g)}getListPartsUrl(){return this.buildApiUrl(m)}getListUnfinishedLargeFilesUrl(){return this.buildApiUrl(b)}getCreateKeyUrl(){return this.buildApiUrl(E)}getDeleteKeyUrl(){return this.buildApiUrl(I)}getListKeysUrl(){return this.buildApiUrl(k)}getDownloadAuthorizationUrl(){return this.buildApiUrl(v)}}class ft{constructor(t,e,r={}){this.httpClient=t,this.authManager=e,this.config=r,this.endpointBuilder=new pt}validateBucketName(t){if(!t||"string"!=typeof t)throw new Error("bucketName is required and must be a string");if(t.length<6||t.length>50)throw new Error("Bucket name must be between 6 and 50 characters");if(!/^[a-z0-9][a-z0-9\-]*[a-z0-9]$/.test(t))throw new Error("Bucket name must start and end with alphanumeric characters and contain only lowercase letters, numbers, and hyphens");if(t.includes("--"))throw new Error("Bucket name cannot contain consecutive hyphens")}validateBucketType(t){if(!t||"string"!=typeof t)throw new Error("bucketType is required and must be a string");const e=Object.values(A);if(!e.includes(t))throw new Error(`Invalid bucket type. Must be one of: ${e.join(", ")}`)}validateBucketId(t){if(!t||"string"!=typeof t)throw new Error("bucketId is required and must be a string");if(0===t.trim().length)throw new Error("bucketId cannot be empty")}ensureAuthenticated(){if(!this.authManager.isAuthenticated())throw new Error("Not authenticated. Call authorize() first.");this.endpointBuilder.setAuthContext(this.authManager.getAuthContext())}async create(t,e){let r,i;if(this.ensureAuthenticated(),"string"==typeof t)r=t,i=e;else{if(!t||"object"!=typeof t)throw new Error("Invalid arguments. Expected object with bucketName and bucketType, or bucketName and bucketType as separate parameters");r=t.bucketName,i=t.bucketType}this.validateBucketName(r),this.validateBucketType(i);const a={accountId:this.authManager.getAccountId(),bucketName:r,bucketType:i};try{return await this.httpClient.post(this.endpointBuilder.getCreateBucketUrl(),a,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(s){if(400===s.status){if(s.code===V){const t=new Error(`Bucket name '${r}' already exists`);throw t.code=V,t.status=400,t}if(s.code===O){const t=new Error(`Invalid bucket name: ${r}`);throw t.code=O,t.status=400,t}}throw s}}async delete(t){let e;if(this.ensureAuthenticated(),"string"==typeof t)e=t;else{if(!t||"object"!=typeof t)throw new Error("Invalid arguments. Expected object with bucketId or bucketId as string");e=t.bucketId}this.validateBucketId(e);const r={accountId:this.authManager.getAccountId(),bucketId:e};try{return await this.httpClient.post(this.endpointBuilder.getDeleteBucketUrl(),r,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(i){if(400===i.status){if(i.code===q){const t=new Error(`Invalid bucket ID: ${e}`);throw t.code=q,t.status=400,t}if(i.code===W){const t=new Error("Bucket is not empty and cannot be deleted");throw t.code=W,t.status=400,t}}throw i}}async list(t={}){this.ensureAuthenticated();const e={accountId:this.authManager.getAccountId()};try{return await this.httpClient.post(this.endpointBuilder.getListBucketsUrl(),e,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(r){throw r}}async get(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");if(!t.bucketName&&!t.bucketId)throw new Error("Either bucketName or bucketId is required");if(t.bucketName&&t.bucketId)throw new Error("Cannot specify both bucketName and bucketId");const e={accountId:this.authManager.getAccountId()};t.bucketName?(this.validateBucketName(t.bucketName),e.bucketName=t.bucketName):(this.validateBucketId(t.bucketId),e.bucketId=t.bucketId);try{return await this.httpClient.post(this.endpointBuilder.getListBucketsUrl(),e,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(r){throw r}}async update(t,e){let r,i;if(this.ensureAuthenticated(),"string"==typeof t)r=t,i=e;else{if(!t||"object"!=typeof t)throw new Error("Invalid arguments. Expected object with bucketId and bucketType, or bucketId and bucketType as separate parameters");r=t.bucketId,i=t.bucketType}this.validateBucketId(r),this.validateBucketType(i);const a={accountId:this.authManager.getAccountId(),bucketId:r,bucketType:i};try{return await this.httpClient.post(this.endpointBuilder.getUpdateBucketUrl(),a,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(s){if(400===s.status&&s.code===q){const t=new Error(`Invalid bucket ID: ${r}`);throw t.code=q,t.status=400,t}throw s}}async getUploadUrl(t){let e;if(this.ensureAuthenticated(),"string"==typeof t)e=t;else{if(!t||"object"!=typeof t)throw new Error("Invalid arguments. Expected object with bucketId or bucketId as string");e=t.bucketId}this.validateBucketId(e);const r={bucketId:e};try{return await this.httpClient.post(this.endpointBuilder.getUploadUrl(),r,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(i){if(400===i.status&&i.code===q){const t=new Error(`Invalid bucket ID: ${e}`);throw t.code=q,t.status=400,t}throw i}}}const yt="undefined"!=typeof process&&process.versions&&process.versions.node;let wt,gt;function mt(){return wt||(yt?(gt||(gt=import("crypto").then(t=>(wt=t,wt))),gt):(wt=globalThis.crypto,wt))}class bt{static async hash(t){return yt?this.hashNode(t):this.hashBrowser(t)}static async hashNode(t){const e=(await mt()).createHash("sha1");return e.update(t),e.digest("hex")}static async hashBrowser(t){"string"==typeof t&&(t=(new TextEncoder).encode(t));const e=await wt.subtle.digest("SHA-1",t),r=new Uint8Array(e);return Array.from(r).map(t=>t.toString(16).padStart(2,"0")).join("")}static createStream(){return new Et}static async verify(t,e){return(await this.hash(t)).toLowerCase()===e.toLowerCase()}static async hashFile(t){if(!yt)throw new Error("File hashing is only available in Node.js environment");const e=(await import("fs")).createReadStream(t),r=this.createStream();return new Promise((t,i)=>{e.on("data",t=>r.update(t)),e.on("end",()=>t(r.digest())),e.on("error",i)})}}class Et{constructor(){this.isNode=yt,yt?(this.cryptoPromise=mt(),this.hash=null):this.chunks=[]}async init(){if(this.isNode&&!this.hash){const t=await this.cryptoPromise;this.hash=t.createHash("sha1")}}async update(t){this.isNode?(await this.init(),this.hash.update(t)):("string"==typeof t&&(t=(new TextEncoder).encode(t)),this.chunks.push(t))}async digest(){if(this.isNode)return await this.init(),this.hash.digest("hex");{const t=this.chunks.reduce((t,e)=>t+e.length,0),e=new Uint8Array(t);let r=0;for(const i of this.chunks)e.set(i,r),r+=i.length;return bt.hashBrowser(e)}}}bt.hash.bind(bt),bt.verify.bind(bt),bt.createStream.bind(bt);class It{constructor(t,e,r={}){this.httpClient=t,this.authManager=e,this.config=r,this.endpointBuilder=new pt}ensureAuthenticated(){if(!this.authManager.isAuthenticated())throw new Error("Not authenticated. Call authorize() first.");this.endpointBuilder.setAuthContext(this.authManager.getAuthContext())}validateFileName(t){if("string"!=typeof t)throw new Error("fileName is required and must be a string");if(0===t.length)throw new Error("File name cannot be empty");if(t.length>1024)throw new Error("File name cannot exceed 1024 characters");if(/[\x00-\x1f\x7f]/.test(t))throw new Error("File name contains invalid characters")}validateFileId(t){if("string"!=typeof t)throw new Error("fileId is required and must be a string");if(0===t.trim().length)throw new Error("fileId cannot be empty")}async uploadFile(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{uploadUrl:e,uploadAuthToken:r,fileName:i,data:a,contentType:s=Q.OCTET_STREAM,contentSha1:n,info:o,onUploadProgress:u}=t;if(!e||"string"!=typeof e)throw new Error("uploadUrl is required and must be a string");if(!r||"string"!=typeof r)throw new Error("uploadAuthToken is required and must be a string");if(this.validateFileName(i),!a)throw new Error("data is required");let h;h="string"==typeof a?(new TextEncoder).encode(a).length:a.length;let l=n;l||(l=await bt.hash(a));const c=ct.createUploadHeaders({authToken:r,fileName:i,contentType:s,contentSha1:l,contentLength:h,info:o});try{return await this.httpClient.post(e,a,{headers:c,timeout:this.config.uploadTimeout||this.config.timeout,onUploadProgress:u})}catch(d){if(400===d.status&&d.code===J){const t=new Error(`File upload failed: ${d.message}`);throw t.code=J,t.status=400,t}throw d}}async getFileInfo(t){let e;if(this.ensureAuthenticated(),"string"==typeof t)e=t;else{if(!t||"object"!=typeof t)throw new Error("Invalid arguments. Expected object with fileId or fileId as string");e=t.fileId}this.validateFileId(e);const r={fileId:e};try{return await this.httpClient.post(this.endpointBuilder.getFileInfoUrl(),r,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(i){if(400===i.status&&i.code===J){const t=new Error(`File not found: ${e}`);throw t.code=J,t.status=400,t}throw i}}async deleteFileVersion(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{fileId:e,fileName:r}=t;this.validateFileId(e),this.validateFileName(r);const i={fileId:e,fileName:r};try{return await this.httpClient.post(this.endpointBuilder.getDeleteFileVersionUrl(),i,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(a){if(400===a.status&&a.code===J){const t=new Error(`File not found: ${e}`);throw t.code=J,t.status=400,t}throw a}}async listFileNames(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{bucketId:e,startFileName:r,maxFileCount:i,prefix:a,delimiter:s}=t;if("string"!=typeof e)throw new Error("bucketId is required and must be a string");if(0===e.trim().length)throw new Error("bucketId cannot be empty");if(void 0!==i&&("number"!=typeof i||i<1||i>1e4))throw new Error("maxFileCount must be a number between 1 and 10000");if(void 0!==r&&"string"!=typeof r)throw new Error("startFileName must be a string");if(void 0!==a&&"string"!=typeof a)throw new Error("prefix must be a string");if(void 0!==s&&"string"!=typeof s)throw new Error("delimiter must be a string");const n={bucketId:e};void 0!==r&&(n.startFileName=r),void 0!==i&&(n.maxFileCount=i),void 0!==a&&(n.prefix=a),void 0!==s&&(n.delimiter=s);try{return await this.httpClient.post(this.endpointBuilder.getListFileNamesUrl(),n,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(o){if(400===o.status&&o.code===q){const t=new Error(`Invalid bucket ID: ${e}`);throw t.code=q,t.status=400,t}throw o}}async listFileVersions(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{bucketId:e,startFileName:r,startFileId:i,maxFileCount:a,prefix:s,delimiter:n}=t;if("string"!=typeof e)throw new Error("bucketId is required and must be a string");if(0===e.trim().length)throw new Error("bucketId cannot be empty");if(void 0!==a&&("number"!=typeof a||a<1||a>1e4))throw new Error("maxFileCount must be a number between 1 and 10000");if(void 0!==r&&"string"!=typeof r)throw new Error("startFileName must be a string");if(void 0!==i&&"string"!=typeof i)throw new Error("startFileId must be a string");if(void 0!==s&&"string"!=typeof s)throw new Error("prefix must be a string");if(void 0!==n&&"string"!=typeof n)throw new Error("delimiter must be a string");const o={bucketId:e};void 0!==r&&(o.startFileName=r),void 0!==i&&(o.startFileId=i),void 0!==a&&(o.maxFileCount=a),void 0!==s&&(o.prefix=s),void 0!==n&&(o.delimiter=n);try{return await this.httpClient.post(this.endpointBuilder.getListFileVersionsUrl(),o,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(u){if(400===u.status&&u.code===q){const t=new Error(`Invalid bucket ID: ${e}`);throw t.code=q,t.status=400,t}throw u}}async hideFile(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{bucketId:e,fileName:r}=t;if("string"!=typeof e)throw new Error("bucketId is required and must be a string");if(0===e.trim().length)throw new Error("bucketId cannot be empty");this.validateFileName(r);const i={bucketId:e,fileName:r};try{return await this.httpClient.post(this.endpointBuilder.getHideFileUrl(),i,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(a){if(400===a.status){if(a.code===q){const t=new Error(`Invalid bucket ID: ${e}`);throw t.code=q,t.status=400,t}if(a.code===J){const t=new Error(`File not found: ${r}`);throw t.code=J,t.status=400,t}}throw a}}async downloadFileByName(t,e){let r,i,a,s,n;if(this.ensureAuthenticated(),"string"==typeof t)r=t,i=e,a="arraybuffer",s=void 0,n={};else{if(!t||"object"!=typeof t)throw new Error("Invalid arguments. Expected object with bucketName and fileName, or bucketName and fileName as separate strings");r=t.bucketName,i=t.fileName,a=t.responseType||"arraybuffer",s=t.onDownloadProgress,n=t.headers||{}}if("string"!=typeof r)throw new Error("bucketName is required and must be a string");if(0===r.trim().length)throw new Error("bucketName cannot be empty");this.validateFileName(i);const o=["json","text","arraybuffer","blob","stream"];if(!o.includes(a))throw new Error(`Invalid responseType. Must be one of: ${o.join(", ")}`);try{const t=this.endpointBuilder.getDownloadFileByNameUrl(r,i);return await this.httpClient.get(t,{headers:{...this.authManager.getAuthHeaders(),...n},responseType:a,onDownloadProgress:s,timeout:this.config.downloadTimeout||this.config.timeout})}catch(u){if(404===u.status){const t=new Error(`File not found: ${i} in bucket ${r}`);throw t.code=J,t.status=404,t}if(401===u.status){const t=new Error(`Unauthorized access to file: ${i}`);throw t.code=z,t.status=401,t}throw u}}async downloadFileById(t){let e,r,i,a;if(this.ensureAuthenticated(),"string"==typeof t)e=t,r="arraybuffer",i=void 0,a={};else{if(!t||"object"!=typeof t)throw new Error("Invalid arguments. Expected object with fileId or fileId as string");e=t.fileId,r=t.responseType||"arraybuffer",i=t.onDownloadProgress,a=t.headers||{}}this.validateFileId(e);const s=["json","text","arraybuffer","blob","stream"];if(!s.includes(r))throw new Error(`Invalid responseType. Must be one of: ${s.join(", ")}`);try{const t=this.endpointBuilder.getDownloadFileByIdUrl(e);return await this.httpClient.get(t,{headers:{...this.authManager.getAuthHeaders(),...a},responseType:r,onDownloadProgress:i,timeout:this.config.downloadTimeout||this.config.timeout})}catch(n){if(404===n.status){const t=new Error(`File not found: ${e}`);throw t.code=J,t.status=404,t}if(401===n.status){const t=new Error(`Unauthorized access to file: ${e}`);throw t.code=z,t.status=401,t}throw n}}async getDownloadAuthorization(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{bucketId:e,fileNamePrefix:r,validDurationInSeconds:i=604800,b2ContentDisposition:a}=t;if("string"!=typeof e)throw new Error("bucketId is required and must be a string");if(0===e.trim().length)throw new Error("bucketId cannot be empty");if("string"!=typeof r)throw new Error("fileNamePrefix is required and must be a string (can be empty)");if(void 0!==i&&("number"!=typeof i||i<1||i>604800))throw new Error("validDurationInSeconds must be a number between 1 and 604800 (7 days)");if(void 0!==a&&"string"!=typeof a)throw new Error("b2ContentDisposition must be a string");const s={bucketId:e,fileNamePrefix:r,validDurationInSeconds:i};void 0!==a&&(s.b2ContentDisposition=a);try{return await this.httpClient.post(this.endpointBuilder.getDownloadAuthorizationUrl(),s,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(n){if(400===n.status){if(n.code===q){const t=new Error(`Invalid bucket ID: ${e}`);throw t.code=q,t.status=400,t}if(n.code===X){const t=new Error(`Not allowed to get download authorization for bucket: ${e}`);throw t.code=X,t.status=400,t}}if(401===n.status){const t=new Error("Unauthorized: Invalid credentials for download authorization");throw t.code=z,t.status=401,t}throw n}}async startLargeFile(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{bucketId:e,fileName:r,contentType:i=Q.OCTET_STREAM,fileInfo:a}=t;if("string"!=typeof e)throw new Error("bucketId is required and must be a string");if(0===e.trim().length)throw new Error("bucketId cannot be empty");if(this.validateFileName(r),void 0!==i&&"string"!=typeof i)throw new Error("contentType must be a string");if(void 0!==a&&("object"!=typeof a||null===a))throw new Error("fileInfo must be an object");const s={bucketId:e,fileName:r,contentType:i};a&&(s.fileInfo=a);try{return await this.httpClient.post(this.endpointBuilder.getStartLargeFileUrl(),s,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(n){if(400===n.status){if(n.code===q){const t=new Error(`Invalid bucket ID: ${e}`);throw t.code=q,t.status=400,t}if(n.code===X){const t=new Error(`Not allowed to upload to bucket: ${e}`);throw t.code=X,t.status=400,t}}if(401===n.status){const t=new Error("Unauthorized: Invalid credentials for large file upload");throw t.code=z,t.status=401,t}throw n}}async getUploadPartUrl(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{fileId:e}=t;this.validateFileId(e);const r={fileId:e};try{return await this.httpClient.post(this.endpointBuilder.getUploadPartUrlEndpoint(),r,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(i){if(400===i.status&&i.code===J){const t=new Error(`Large file not found: ${e}`);throw t.code=J,t.status=400,t}if(401===i.status){const t=new Error("Unauthorized: Invalid credentials for upload part URL");throw t.code=z,t.status=401,t}throw i}}async uploadPart(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{uploadUrl:e,authorizationToken:r,partNumber:i,data:a,contentSha1:s,onUploadProgress:n}=t;if(!e||"string"!=typeof e)throw new Error("uploadUrl is required and must be a string");if(!r||"string"!=typeof r)throw new Error("authorizationToken is required and must be a string");if("number"!=typeof i||i<1||i>1e4)throw new Error("partNumber must be a number between 1 and 10000");if(!a)throw new Error("data is required");let o;o="string"==typeof a?(new TextEncoder).encode(a).length:a.length;const u=5368709120;if(o>u)throw new Error("Part size cannot exceed 5368709120 bytes (5GB)");let h=s;h||(h=await bt.hash(a));const l={Authorization:r,"Content-Type":Q.OCTET_STREAM,"Content-Length":o.toString(),"X-Bz-Content-Sha1":h,"X-Bz-Part-Number":i.toString()};try{return await this.httpClient.post(e,a,{headers:l,timeout:this.config.uploadTimeout||this.config.timeout,onUploadProgress:n})}catch(c){if(400===c.status&&c.code===J){const t=new Error(`Large file upload failed: ${c.message}`);throw t.code=J,t.status=400,t}throw c}}async finishLargeFile(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{fileId:e,partSha1Array:r}=t;if(this.validateFileId(e),!Array.isArray(r))throw new Error("partSha1Array is required and must be an array");if(0===r.length)throw new Error("partSha1Array cannot be empty");if(r.length>j)throw new Error(`partSha1Array cannot have more than ${j} parts`);r.forEach((t,e)=>{if("string"!=typeof t)throw new Error(`partSha1Array[${e}] must be a string`);if(40!==t.length)throw new Error(`partSha1Array[${e}] must be a 40-character SHA1 hash`);if(!/^[a-fA-F0-9]{40}$/.test(t))throw new Error(`partSha1Array[${e}] must be a valid hexadecimal SHA1 hash`)});const i={fileId:e,partSha1Array:r};try{return await this.httpClient.post(this.endpointBuilder.getFinishLargeFileUrl(),i,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(a){if(400===a.status&&a.code===J){const t=new Error(`Large file not found: ${e}`);throw t.code=J,t.status=400,t}if(401===a.status){const t=new Error("Unauthorized: Invalid credentials for finishing large file");throw t.code=z,t.status=401,t}throw a}}async cancelLargeFile(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{fileId:e}=t;this.validateFileId(e);const r={fileId:e};try{return await this.httpClient.post(this.endpointBuilder.getCancelLargeFileUrl(),r,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(i){if(400===i.status&&i.code===J){const t=new Error(`Large file not found: ${e}`);throw t.code=J,t.status=400,t}if(401===i.status){const t=new Error("Unauthorized: Invalid credentials for canceling large file");throw t.code=z,t.status=401,t}throw i}}async listParts(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{fileId:e,startPartNumber:r,maxPartCount:i}=t;if(this.validateFileId(e),void 0!==r&&("number"!=typeof r||r<1||r>j))throw new Error(`startPartNumber must be a number between 1 and ${j}`);if(void 0!==i&&("number"!=typeof i||i<1||i>1e4))throw new Error("maxPartCount must be a number between 1 and 10000");const a={fileId:e};void 0!==r&&(a.startPartNumber=r),void 0!==i&&(a.maxPartCount=i);try{return await this.httpClient.post(this.endpointBuilder.getListPartsUrl(),a,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(s){if(400===s.status&&s.code===J){const t=new Error(`Large file not found: ${e}`);throw t.code=J,t.status=400,t}if(401===s.status){const t=new Error("Unauthorized: Invalid credentials for listing parts");throw t.code=z,t.status=401,t}throw s}}async listUnfinishedLargeFiles(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{bucketId:e,startFileId:r,maxFileCount:i}=t;if("string"!=typeof e)throw new Error("bucketId is required and must be a string");if(0===e.trim().length)throw new Error("bucketId cannot be empty");if(void 0!==i&&("number"!=typeof i||i<1||i>1e4))throw new Error("maxFileCount must be a number between 1 and 10000");if(void 0!==r&&"string"!=typeof r)throw new Error("startFileId must be a string");const a={bucketId:e};void 0!==r&&(a.startFileId=r),void 0!==i&&(a.maxFileCount=i);try{return await this.httpClient.post(this.endpointBuilder.getListUnfinishedLargeFilesUrl(),a,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(s){if(400===s.status&&s.code===q){const t=new Error(`Invalid bucket ID: ${e}`);throw t.code=q,t.status=400,t}throw s}}}class kt{constructor(t,e,r={}){this.httpClient=t,this.authManager=e,this.config=r,this.endpointBuilder=new pt}validateKeyName(t){if(null==t||"string"!=typeof t)throw new Error("keyName is required and must be a string");if(t.length<1||t.length>100)throw new Error("Key name must be between 1 and 100 characters");if(!/^[a-zA-Z0-9\-_\.]+$/.test(t))throw new Error("Key name can only contain letters, numbers, hyphens, underscores, and periods")}validateCapabilities(t){if(!Array.isArray(t))throw new Error("capabilities must be an array");if(0===t.length)throw new Error("At least one capability is required");const e=Object.values(x);for(const r of t){if("string"!=typeof r)throw new Error("All capabilities must be strings");if(!e.includes(r))throw new Error(`Invalid capability: ${r}. Must be one of: ${e.join(", ")}`)}if([...new Set(t)].length!==t.length)throw new Error("Duplicate capabilities are not allowed")}validateKeyId(t){if(null==t||"string"!=typeof t)throw new Error("applicationKeyId is required and must be a string");if(0===t.trim().length)throw new Error("applicationKeyId cannot be empty")}validateBucketId(t){if(null!=t){if("string"!=typeof t)throw new Error("bucketId must be a string or null");if(0===t.trim().length)throw new Error("bucketId cannot be empty string")}}validateNamePrefix(t){if(null!=t&&"string"!=typeof t)throw new Error("namePrefix must be a string or null")}ensureAuthenticated(){if(!this.authManager.isAuthenticated())throw new Error("Not authenticated. Call authorize() first.");this.endpointBuilder.setAuthContext(this.authManager.getAuthContext())}async createKey(t){if(this.ensureAuthenticated(),!t||"object"!=typeof t)throw new Error("options object is required");const{keyName:e,capabilities:r,bucketId:i,namePrefix:a,validDurationInSeconds:s}=t;if(this.validateKeyName(e),this.validateCapabilities(r),this.validateBucketId(i),this.validateNamePrefix(a),void 0!==s){if("number"!=typeof s||s<=0)throw new Error("validDurationInSeconds must be a positive number");if(s>864e5)throw new Error("validDurationInSeconds cannot exceed 1000 days")}const n={accountId:this.authManager.getAccountId(),keyName:e,capabilities:r};i&&(n.bucketId=i),void 0!==a&&(n.namePrefix=a),void 0!==s&&(n.validDurationInSeconds=s);try{return await this.httpClient.post(this.endpointBuilder.getCreateKeyUrl(),n,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(o){if(400===o.status){if(o.code===q){const t=new Error(`Invalid bucket ID: ${i}`);throw t.code=q,t.status=400,t}if(o.code===X){const t=new Error("Not allowed to create keys with the specified capabilities");throw t.code=X,t.status=400,t}}throw o}}async deleteKey(t){let e;if(this.ensureAuthenticated(),"string"==typeof t)e=t;else{if(!t||"object"!=typeof t)throw new Error("Invalid arguments. Expected object with applicationKeyId or applicationKeyId as string");e=t.applicationKeyId}this.validateKeyId(e);const r={applicationKeyId:e};try{return await this.httpClient.post(this.endpointBuilder.getDeleteKeyUrl(),r,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(i){if(400===i.status){const t=new Error(`Invalid application key ID: ${e}`);throw t.code=X,t.status=400,t}throw i}}async listKeys(t={}){if(this.ensureAuthenticated(),t&&"object"!=typeof t)throw new Error("options must be an object");const{maxKeyCount:e,startApplicationKeyId:r}=t;if(void 0!==e&&("number"!=typeof e||e<=0||e>1e4))throw new Error("maxKeyCount must be a number between 1 and 10000");void 0!==r&&this.validateKeyId(r);const i={accountId:this.authManager.getAccountId()};void 0!==e&&(i.maxKeyCount=e),void 0!==r&&(i.startApplicationKeyId=r);try{return await this.httpClient.post(this.endpointBuilder.getListKeysUrl(),i,{headers:this.authManager.getAuthHeaders(),timeout:this.config.timeout})}catch(a){throw a}}}class vt{constructor(e={}){if(e&&"object"!=typeof e)throw new Error("options must be an object");this.accountId=e.accountId||null,this.applicationKeyId=e.applicationKeyId||null,this.applicationKey=e.applicationKey||null,this.apiUrl=e.apiUrl||t,this.authorizationToken=null,this.downloadUrl=null,this.config={timeout:e.timeout||$,retries:e.retries||D,retryDelay:e.retryDelay||L,retryDelayMultiplier:e.retryDelayMultiplier||H,maxRetryDelay:e.maxRetryDelay||P,headers:e.headers||{},...e};const r={retries:this.config.retries,retryDelay:this.config.retryDelay,retryDelayMultiplier:this.config.retryDelayMultiplier,maxRetryDelay:this.config.maxRetryDelay};this.retryHandler=new ut(r);const i={baseURL:this.config.apiUrl,timeout:this.config.timeout,headers:this.config.headers};this.httpClient=new ot(i),this.authManager=new dt(this.httpClient,this.config),this.bucketManager=new ft(this.httpClient,this.authManager,this.config),this.fileManager=new It(this.httpClient,this.authManager,this.config),this.keyManager=new kt(this.httpClient,this.authManager,this.config),this.credentials=null,this.BUCKET_TYPES=A,this.KEY_CAPABILITIES=x}async authorize(t,e){let r;if("string"==typeof t)r={applicationKeyId:t,applicationKey:e};else if(t&&"object"==typeof t)r={applicationKeyId:t.applicationKeyId,applicationKey:t.applicationKey};else{if(t||!this.applicationKeyId||!this.applicationKey)throw new Error("Invalid arguments. Expected object with applicationKeyId and applicationKey, or applicationKeyId and applicationKey as separate strings");r={applicationKeyId:this.applicationKeyId,applicationKey:this.applicationKey}}this.credentials=r;const i=await this.retryHandler.executeWithRetry(async()=>this.authManager.authorize(r,{timeout:this.config.timeout}));return i&&i.data&&(this.authorizationToken=i.data.authorizationToken,this.apiUrl=i.data.apiUrl,this.downloadUrl=i.data.downloadUrl),i}async createBucket(t,e){return this.retryHandler.executeWithRetry(async()=>this.bucketManager.create(t,e))}async deleteBucket(t){return this.retryHandler.executeWithRetry(async()=>this.bucketManager.delete(t))}async listBuckets(t={}){return this.retryHandler.executeWithRetry(async()=>this.bucketManager.list(t))}async getBucket(t){return this.retryHandler.executeWithRetry(async()=>this.bucketManager.get(t))}async updateBucket(t,e){return this.retryHandler.executeWithRetry(async()=>this.bucketManager.update(t,e))}async getUploadUrl(t){return this.retryHandler.executeWithRetry(async()=>this.bucketManager.getUploadUrl(t))}async uploadFile(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.uploadFile(t))}async downloadFileByName(t,e){return this.retryHandler.executeWithRetry(async()=>this.fileManager.downloadFileByName(t,e))}async downloadFileById(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.downloadFileById(t))}async listFileNames(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.listFileNames(t))}async listFileVersions(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.listFileVersions(t))}async getFileInfo(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.getFileInfo(t))}async deleteFileVersion(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.deleteFileVersion(t))}async hideFile(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.hideFile(t))}async getDownloadAuthorization(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.getDownloadAuthorization(t))}async startLargeFile(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.startLargeFile(t))}async getUploadPartUrl(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.getUploadPartUrl(t))}async uploadPart(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.uploadPart(t))}async finishLargeFile(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.finishLargeFile(t))}async cancelLargeFile(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.cancelLargeFile(t))}async listParts(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.listParts(t))}async listUnfinishedLargeFiles(t){return this.retryHandler.executeWithRetry(async()=>this.fileManager.listUnfinishedLargeFiles(t))}async createKey(t){return this.retryHandler.executeWithRetry(async()=>this.keyManager.createKey(t))}async deleteKey(t){return this.retryHandler.executeWithRetry(async()=>this.keyManager.deleteKey(t))}async listKeys(t={}){return this.retryHandler.executeWithRetry(async()=>this.keyManager.listKeys(t))}isAuthenticated(){return this.authManager.isAuthenticated()}getAuthContext(){return this.authManager.getAuthContext()}clearAuth(){this.authManager.clearAuthContext(),this.credentials=null,this.authorizationToken=null,this.apiUrl=null,this.downloadUrl=null}async refreshAuth(){if(!this.credentials)throw new Error("No credentials stored. Call authorize() first.");return this.authorize(this.credentials)}saveAuthContext(t){this.authManager.saveAuthContext(t),t&&"object"==typeof t&&(this.authorizationToken=t.authorizationToken||null,this.apiUrl=t.apiUrl||null,this.downloadUrl=t.downloadUrl||null)}}class At extends Error{constructor(t,e={}){super(t),this.name="B2Error",this.status=e.status,this.statusText=e.statusText,this.code=e.code,this.response=e.response,this.request=e.request,this.isRetryable=e.isRetryable??!1,this.isNetworkError=e.isNetworkError??!1,this.isHttpError=e.isHttpError??!1,this.retryAttempts=e.retryAttempts??0,this.isRetryExhausted=e.isRetryExhausted??!1,Error.captureStackTrace&&Error.captureStackTrace(this,At)}toJSON(){return{name:this.name,message:this.message,status:this.status,statusText:this.statusText,code:this.code,isRetryable:this.isRetryable,isNetworkError:this.isNetworkError,isHttpError:this.isHttpError,retryAttempts:this.retryAttempts,isRetryExhausted:this.isRetryExhausted,stack:this.stack}}getDescription(){if(this.isNetworkError)return`Network error: ${this.message}`;if(this.status){const t=this.statusText?` ${this.statusText}`:"",e=this.code?` (${this.code})`:"";return`HTTP ${this.status}${t}${e}: ${this.message}`}return this.message}}exports.AuthHeaders=ht,exports.AuthManager=dt,exports.B2Client=vt,exports.B2Error=At,exports.BUCKET_TYPES=A,exports.BucketManager=ft,exports.EndpointBuilder=pt,exports.ErrorHandler=class{constructor(t={}){this.debug=t.debug??!1,this.logger=t.logger||console}isRetryable(t){return!!t.isNetworkError||(!(!t.status||!G.has(t.status))||(!(!t.code||!Y.has(t.code))||t.status>=500&&t.status<600))}classifyError(t){return t.isNetworkError?"NETWORK_ERROR":t.status?t.status===T?"AUTHENTICATION_ERROR":t.status===C?"AUTHORIZATION_ERROR":t.status===R?"NOT_FOUND_ERROR":t.status===M?"RATE_LIMIT_ERROR":t.status===N?"TIMEOUT_ERROR":t.status>=400&&t.status<500?"CLIENT_ERROR":t.status>=500&&t.status<600?"SERVER_ERROR":"HTTP_ERROR":"UNKNOWN_ERROR"}parseB2ErrorResponse(t,e){let r=null,i=null;return e&&"object"==typeof e&&(r=e.code||e.error_code||null,i=e.message||e.error_message||e.error||null),i||(i=t.statusText||`HTTP ${t.status}`),{code:r,message:i,status:t.status,statusText:t.statusText}}createHttpError(t,e,r=null){const i=this.parseB2ErrorResponse(t,e),a=this.isRetryable({status:i.status,code:i.code}),s=new At(i.message,{status:i.status,statusText:i.statusText,code:i.code,response:{status:t.status,statusText:t.statusText,headers:t.headers,data:e},request:r,isRetryable:a,isHttpError:!0});return this.debug&&this.logger.error("HTTP Error:",s.toJSON()),s}createNetworkError(t,e=null){let r="Network error occurred",i="NETWORK_ERROR";"AbortError"===t.name?(r="Request timeout",i="TIMEOUT"):t.message&&(r=`Network error: ${t.message}`);const a=new At(r,{code:i,request:e,isRetryable:!0,isNetworkError:!0});return a.originalError=t,this.debug&&this.logger.error("Network Error:",a.toJSON()),a}createAuthError(t,e=null){const r=new At(t,{status:T,statusText:"Unauthorized",code:z,response:e,isRetryable:!1,isHttpError:!0});return this.debug&&this.logger.error("Authentication Error:",r.toJSON()),r}createValidationError(t,e=null){const r=new At(e?`Validation error for ${e}: ${t}`:`Validation error: ${t}`,{status:U,statusText:"Bad Request",code:"VALIDATION_ERROR",isRetryable:!1,isHttpError:!1});return e&&(r.field=e),this.debug&&this.logger.error("Validation Error:",r.toJSON()),r}enhanceError(t,e={}){if(t instanceof At)return Object.assign(t,e),t;const r=new At(t.message,{...e,stack:t.stack});return r.originalError=t,r}formatError(t,e=!1){const r={type:this.classifyError(t),message:t.message,description:t instanceof At?t.getDescription():t.message};return t.status&&(r.status=t.status,r.statusText=t.statusText),t.code&&(r.code=t.code),void 0!==t.isRetryable&&(r.isRetryable=t.isRetryable),void 0!==t.retryAttempts&&(r.retryAttempts=t.retryAttempts),e&&t.stack&&(r.stack=t.stack),r}logError(t,e={}){if(!this.debug)return;const r={...this.formatError(t,!0),...e};t.isNetworkError||t.status&&t.status>=500?this.logger.error("B2 Error:",r):t.status&&t.status>=400?this.logger.warn("B2 Client Error:",r):this.logger.info("B2 Info:",r)}isAuthExpired(t){return t.status===T||t.code===K||t.code===z}isRateLimited(t){return t.status===M||t.code===Z}getRateLimitDelay(t){if(t.response&&t.response.headers){const e=t.response.headers.get("Retry-After");if(e){const t=parseInt(e,10);if(!isNaN(t))return 1e3*t}}return 6e4}},exports.FileManager=It,exports.HeaderUtils=ct,exports.HttpClient=ot,exports.KEY_CAPABILITIES=x,exports.KeyManager=kt,exports.ProgressHandler=nt,exports.RetryHandler=ut,exports.Sha1Hasher=bt,exports.Validator=class{static validateRequired(t,e){if(!t||"object"!=typeof t)throw new Error("Parameters object is required");const r=e.filter(e=>void 0===t[e]||null===t[e]||""===t[e]);if(r.length>0)throw new Error(`Missing required parameters: ${r.join(", ")}`)}static validateString(t,e,r={}){if("string"!=typeof t)throw new Error(`${e} must be a string`);if(void 0!==r.minLength&&t.length<r.minLength)throw new Error(`${e} must be at least ${r.minLength} characters long`);if(void 0!==r.maxLength&&t.length>r.maxLength)throw new Error(`${e} must be no more than ${r.maxLength} characters long`);if(r.pattern&&!r.pattern.test(t))throw new Error(`${e} format is invalid`)}static validateNumber(t,e,r={}){if("number"!=typeof t||isNaN(t))throw new Error(`${e} must be a valid number`);if(r.integer&&!Number.isInteger(t))throw new Error(`${e} must be an integer`);if(void 0!==r.min&&t<r.min)throw new Error(`${e} must be at least ${r.min}`);if(void 0!==r.max&&t>r.max)throw new Error(`${e} must be no more than ${r.max}`)}static validateArray(t,e,r={}){if(!Array.isArray(t))throw new Error(`${e} must be an array`);if(void 0!==r.minLength&&t.length<r.minLength)throw new Error(`${e} must contain at least ${r.minLength} items`);if(void 0!==r.maxLength&&t.length>r.maxLength)throw new Error(`${e} must contain no more than ${r.maxLength} items`)}static validateBucketName(t){if(this.validateString(t,"bucketName",{minLength:6,maxLength:50,pattern:/^[a-zA-Z0-9\-]+$/}),t.startsWith("-")||t.endsWith("-"))throw new Error("Bucket name cannot start or end with a hyphen");if(t.includes("--"))throw new Error("Bucket name cannot contain consecutive hyphens")}static validateBucketType(t){const e=Object.values(A);if(!e.includes(t))throw new Error(`Invalid bucket type. Must be one of: ${e.join(", ")}`)}static validateFileName(t){this.validateString(t,"fileName",{minLength:1,maxLength:1024});if(/[\x00-\x1f\x7f]/.test(t))throw new Error("File name contains invalid control characters");if(t.startsWith("/"))throw new Error("File name cannot start with a forward slash")}static validateSha1(t){this.validateString(t,"SHA1 hash",{minLength:40,maxLength:40,pattern:/^[a-fA-F0-9]{40}$/})}static validateContentType(t){this.validateString(t,"contentType",{minLength:1,maxLength:1024,pattern:/^[a-zA-Z0-9][a-zA-Z0-9!#$&\-\^_]*\/[a-zA-Z0-9][a-zA-Z0-9!#$&\-\^_.]*$/})}static validateKeyCapabilities(t){this.validateArray(t,"capabilities",{minLength:1});const e=Object.values(x),r=t.filter(t=>!e.includes(t));if(r.length>0)throw new Error(`Invalid key capabilities: ${r.join(", ")}`)}static validatePartNumber(t){this.validateNumber(t,"partNumber",{min:1,max:1e4,integer:!0})}static validateFileSize(t,e={}){if(this.validateNumber(t,"file size",{min:0,integer:!0}),e.maxSize&&t>e.maxSize)throw new Error(`File size exceeds maximum allowed size of ${e.maxSize} bytes`)}static validatePagination(t){void 0!==t.maxFileCount&&this.validateNumber(t.maxFileCount,"maxFileCount",{min:1,max:1e4,integer:!0}),void 0!==t.startFileName&&this.validateFileName(t.startFileName)}static validateAuthCredentials(t){this.validateRequired(t,["applicationKeyId","applicationKey"]),this.validateString(t.applicationKeyId,"applicationKeyId",{minLength:1,maxLength:1024}),this.validateString(t.applicationKey,"applicationKey",{minLength:1,maxLength:1024})}},exports.default=vt;
//# sourceMappingURL=index.cjs.map
